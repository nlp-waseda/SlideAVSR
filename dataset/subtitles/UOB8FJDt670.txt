utt_0000 utt 1.00 13.52 -X HELLO! WELCOME TO MY TALK ON CUCKOO INDEX. MY NAME IS ANDREAS AND THIS IS A JOINT PROJECT WITH DAMIAN, ALEX, PETER, AND DAVE. THE MAJORITY OF THIS WORK HAS BEEN DONE AT GOOGLE ZURICH.
utt_0002 utt 13.61 18.23 -X I WILL FIRST PROVIDE SOME BACKGROUND ABOUT THE PROBLEM WE ARE TRYING TO SOLVE.
utt_0003 utt 18.23 23.15 -X THEN, I WILL GIVE AN OVERVIEW OVER CUCKOO INDEX AND DIVE INTO A FEW DESIGN CHOICES.
utt_0004 utt 23.79 27.31 -X AND FINALLY, I WILL PRESENT SOME EXPERIMENTAL RESULTS.
utt_0005 utt 29.20 34.93 -X IN MODERN DATA WAREHOUSING, DATA SKIPPING IS ESSENTIAL FOR HIGH QUERY PERFORMANCE.
utt_0006 utt 34.93 42.07 -X FOR EXAMPLE, GOOGLE'S INTERNAL POWERDRILL ENGINE SKIPS MORE THAN ninety% OF DATA ON AVERAGE DURING QUERY EXECUTION.
utt_0007 utt 42.70 46.74 -X THE ENABLER OF THIS HIGH AMOUNT OF DATA SKIPPING ARE SECONDARY INDEXES,
utt_0008 utt 47.28 50.39 -X SUCH AS MIN/MAX VALUES OR BLOOM FILTERS.
utt_0009 utt 52.46 58.96 -X THESE FILTERS ARE TYPICALLY STORED PER COLUMN AND CHUNK OF DATA, OR STRIPE AS WE CALL IT HERE.
utt_0010 utt 59.63 66.29 -X SO FOR EXAMPLE, WHEN QUERYING FOR THE COUNTRY CH, WE PROBE ALL BLOOM FILTERS.
utt_0011 utt 67.03 76.02 -X IF A FILTER RETURNS FALSE, WE KNOW WE CAN SKIP THAT STRIPE. OTHERWISE, WE NEED TO LOAD AND SCAN THE STRIPE.
utt_0012 utt 76.05 81.17 -X CUCKOO INDEX ADDRESSES THREE ISSUES WITH BLOOM FILTERS IN THIS SCENARIO:
utt_0013 utt 81.17 94.04 -X FIRST, ONE NEEDS TO PROBE MULTIPLE FILTERS, WHICH CAN BE EXPENSIVE. SECOND, A UNIQUE VALUE SUCH AS CH MIGHT OCCUR IN MULTIPLE STRIPES AND IS HENCE STORED REDUNDANTLY IN MULTIPLE FILTERS.
utt_0015 utt 94.93 100.44 -X AND THIRD, FILTER LOOKUPS CAN BE FALSE POSITIVE CAUSING UNNECESSARY I/O.
utt_0016 utt 104.28 109.88 -X ON A HIGH LEVEL, CUCKOO INDEX COMBINES CUCKOO FILTERS WITH BITMAP INDEXING.
utt_0017 utt 109.97 116.99 -X A CUCKOO FILTER IS ESSENTIALLY A CUCKOO HASH TABLE WITH THE DIFFERENCE BEING THAT KEYS ARE REPRESENTED BY A SHORT HASH VALUE,
utt_0019 utt 116.99 124.12 -X ALSO CALLED A FINGERPRINT. ALSO, KEYS IN A CUCKOO FILTER DO NOT HAVE AN ASSOCIATED VALUE.
utt_0020 utt 127.67 132.89 -X NOW IN CUCKOO INDEX, EACH FINGERPRINT STORED IN THE FILTER IS ASSOCIATED WITH A VALUE.
utt_0021 utt 133.24 141.15 -X SPECIFICALLY, EACH FINGERPRINT MAPS TO A BITMAP INDICATING QUALIFYING STRIPES. SO FOR EXAMPLE,
utt_0022 utt 141.15 153.88 -X WHEN QUERYING FOR CH HERE, WE FIRST CHECK ITS PRIMARY BUCKET AND FIND THAT Azero DOESN'T MATCH THE STORED FINGERPRINT BE. WE THEN CHECK ITS SECONDARY BUCKET AND FIND A MATCHING FINGERPRINT.
utt_0024 utt 154.84 168.67 -X SO WE RETRIEVE THE CORRESPONDING BITMAP, WHICH DETERMINES THAT WE ONLY NEED TO SCAN STRIPE zero IN THIS CASE. NOTE THAT CUCKOO INDEX PRODUCES one hundred% CORRECT MAPPINGS FOR POSITIVE LOOKUPS.
utt_0026 utt 169.34 174.81 -X THIS IS IN CONTRAST TO PER-STRIPE BLOOM FILTERS, WHICH CAN PRODUCE FALSE POSITIVES.
utt_0027 utt 179.03 187.97 -X IN THE FOLLOWING, I WANT TO GIVE YOU AN IDEA OF THE CHALLENGES THAT COME WITH THIS DESIGN AND HOW WE SOLVED THEM.
utt_0029 utt 188.22 192.83 -X TO ENSURE one hundred% CORRECT LOOKUPS, WE NEED TO RESOLVE FINGERPRINT COLLISIONS DURING INSERTS.
utt_0030 utt 193.56 207.31 -X WE CONSIDERED THREE DIFFERENT OPTIONS. FIRST, ONE COULD UNION THE ASSOCIATED BITMAPS WHICH WON'T CONSUME ANY EXTRA SPACE BUT WILL INTRODUCE FALSE POSITIVES. SECOND, ONE COULD STORE COLLIDING
utt_0032 utt 207.31 212.80 -X ENTRIES IN AN ADDITIONAL FULL-FLEDGED HASH TABLE. THIS DESIGN WILL ENSURE CORRECT LOOKUPS.
utt_0033 utt 213.60 226.59 -X OR THIRD, WE COULD USE VARIABLE-SIZED FINGERPRINTS. SO INSTEAD OF, FOR EXAMPLE, USING eight BITS PER FINGERPRINT, WE USE AS MANY BITS AS NEEDED TO BREAK THE TIE BETWEEN COLLIDING ENTRIES.
utt_0035 utt 227.33 232.51 -X WE OPTED FOR THIS DESIGN AS IT IS BOTH SPACE EFFICIENT AND ENSURES CORRECT LOOKUPS.
utt_0036 utt 236.00 241.70 -X NOW AN INTERESTING INSIGHT IS THAT WE NOT ONLY NEED TO BREAK THE TIE BETWEEN FINGERPRINTS
utt_0037 utt 241.92 253.88 -X IN A CERTAIN BUCKET, BUT WE ALSO NEED TO CONSIDER FINGERPRINTS THAT ARE STORED IN THEIR SECONDARY BUCKET AND HAVE THAT BUCKET AS PRIMARY. THE REASON IS THAT WE COULD ENCOUNTER
utt_0039 utt 254.24 261.38 -X A COLLISION WHEN PROBING A KEY'S PRIMARY BUCKET, EVEN THOUGH IT IS STORED IN ITS SECONDARY BUCKET.
utt_0040 utt 264.32 276.21 -X THAT MEANS KEYS STORED IN THEIR SECONDARY BUCKETS MAY INFLUENCE THE FINGERPRINT LENGTH OF THEIR PRIMARY BUCKET. TO MITIGATE THAT EFFECT, WE WANT TO MAXIMIZE THE NUMBER OF KEYS STORED IN PRIMARY
utt_0042 utt 276.21 289.83 -X BUCKETS, AS THOSE DON'T AFFECT OTHER BUCKETS. TO MAXIMIZE THE PRIMARY RATIO, WE CONSIDERED THREE ALTERNATIVES: AS A BASELINE, WE USE THE CLASSICAL CUCKOO KICKING ALGORITHM. WE ALSO IMPLEMENTED A
utt_0044 utt 289.83 295.27 -X VARIANT BASED ON MAXIMUM WEIGHT MATCHING ON THE CUCKOO GRAPH WHICH FINDS THE OPTIMAL SOLUTION.
utt_0045 utt 295.81 302.28 -X AND, WE DEVISED A HEURISTIC THAT PREFERS KICKING ITEMS THAT RESIDE IN THEIR SECONDARY BUCKET.
utt_0046 utt 302.69 308.36 -X WE FOUND THAT OUR HEURISTIC ACHIEVES PRIMARY RATIOS WITHIN one% OF THE OPTIMUM
utt_0047 utt 308.48 311.88 -X WHILE BEING one hundredX MORE EFFICIENT ON OUR TEST DATA.
utt_0048 utt 312.74 320.14 -X A NICE SIDE EFFECT OF THIS OPTIMIZATION IS THAT KEYS ARE NOW FOUND SOONER DURING LOOKUPS.
utt_0049 utt 322.05 335.27 -X WHILE POSITIVE LOOKUPS ARE MAPPED CORRECTLY, NEGATIVE QUERIES CAN OBVIOUSLY LEAD TO FALSE POSITIVES. SO AFTER PLACING ALL FINGERPRINTS AND MAKING THEM COLLISION FREE, WE MAY ALLOCATE
utt_0051 utt 335.27 340.39 -X ADDITIONAL BITS TO CERTAIN FINGERPRINTS TO CONTROL THE OVERALL FALSE POSITIVE RATE.
utt_0052 utt 340.55 344.49 -X THE INTUITION HERE IS THAT CERTAIN HASH COLLISIONS ARE WORSE THAN OTHERS.
utt_0053 utt 345.10 355.92 -X FOR EXAMPLE, A COLLISION WITH US IN THIS EXAMPLE, WHICH IS ASSOCIATED WITH A DENSE BITMAP, IS WORSE THAN A COLLISION WITH CH, WHICH MAPS TO A SPARSE BITMAP.
utt_0055 utt 356.71 363.05 -X WE HENCE DEVISED A HEURISTIC THAT CONSIDERS BOTH THE PROBABILITY OF A HASH COLLISION AND
utt_0056 utt 363.05 371.85 -X THE DENSITY OF THE ASSOCIATED BITMAP TO CONTROL THE OVERALL FALSE POSITIVE RATE OF THE FILTER.
utt_0057 utt 371.85 381.49 -X NOTE THAT THE PAPER ALSO CONTAINS A DESCRIPTION OF OUR DENSE STORAGE LAYOUT FOR VARIABLE-LENGTH FINGERPRINTS AND OF OUR NEW UNALIGNED BITMAP COMPRESSION SCHEME THAT
utt_0059 utt 381.49 387.92 -X IS MORE SPACE-EFFICIENT THAN ROARING WHILE STILL ALLOWING FOR RANDOM ACCESS.
utt_0060 utt 387.92 396.37 -X FINALLY, LET'S LOOK AT A FEW NUMBERS. HERE ARE SOME RESULTS ON IMDB AND DMV DATA
utt_0061 utt 398.19 405.10 -X WITH sixty-five,zero ROWS PER STRIPE AND A one% FALSE POSITIVE RATE. ON IMDB, WE FOUND
utt_0062 utt 406.64 417.65 -X CUCKOO INDEX TO BE one point fourX TO six point fourX SMALLER THAN BLOOM FILTERS, THE ONLY EXCEPTION BEING THE HIGH-CARDINALITY COLUMN TITLE, FOR WHICH CUCKOO INDEX REQUIRES ten% MORE SPACE.
utt_0064 utt 419.44 424.95 -X HOWEVER, WE ARGUE THAT CUCKOO INDEX IS STILL FAVORABLE OVER BLOOM FILTERS IN THIS CASE,
utt_0065 utt 424.95 432.11 -X SINCE IT DOES NOT PRODUCE ANY FALSE POSITIVES FOR LOOKUPS WITH KEYS THAT OCCUR IN THE DATA. ON DMV,
utt_0066 utt 432.11 438.19 -X CUCKOO INDEX IS CONSISTENTLY SMALLER THAN BLOOM FILTERS WITH SPACE SAVINGS OF UP TO MORE THAN tenX.
utt_0067 utt 441.04 450.96 -X IN THIS EXPERIMENT, WE VARY THE HIT RATE OF LOOKUPS AND SHOW THE FALSE POSITIVE RATE ON THE Y-AXIS. WHILE BLOOM AND XOR, A BLOOM FILTER ALTERNATIVE,
utt_0069 utt 450.96 460.28 -X ARE LARGELY UNAFFECTED BY THE HIT RATE, CUCKOO INDEX STRONGLY BENEFITS FROM AN INCREASING HIT RATE, SINCE IT GUARANTEES EXACT RESULTS FOR POSITIVE LOOKUPS.
utt_0071 utt 463.22 466.16 -4.3950 WITH THAT, I CONCLUDE MY TALK. THANK YOU.
