utt_0000 utt 0.59 3.25 -X HELLO EVERYONE, MY NAME IS TOMER EVEN.
utt_0001 utt 3.25 5.78 -X I’M A MASTER’S STUDENT FROM TEL-AVIV UNIVERSITY.
utt_0002 utt 5.87 10.51 -X IT’S MY PLEASURE TO PRESENT THE “PREFIX FILTER: PRACTICALLY AND THEORETICALLY BETTER THAN BLOOM”.
utt_0004 utt 19.63 20.50 -X WHAT IS A FILTER?
utt_0005 utt 20.50 27.12 -X A FILTER IS A PROBABILISTIC DATA STRUCTURE FOR APPROXIMATELY MAINTAINING A SET OF KEYS S FROM SOME UNIVERSE U, USING SMALL SPACE.
utt_0006 utt 28.14 33.39 -X FILTERS ARE USED TO ANSWER MEMBERSHIP QUERIES WITH ONE-SIDED ERROR.
utt_0007 utt 34.03 41.27 -X THE RESPONSE OF A FILTER TO A MEMBERSHIP QUERY: DOES THE KEY X BELONG TO SET S, IS AS FOLLOWS:
utt_0008 utt 41.27 45.52 -X IF X IS IN S, THE FILTER MUST ANSWER QUERY(X) BY YES.
utt_0009 utt 46.22 53.23 -X IF X IS NOT IN S, THE FILTER USUALLY REPLIES TO QUERY(X) WITH “NO”, BUT IT MIGHT ERR WITH PROBABILITY AT MOST Ε.
utt_0010 utt 53.23 60.63 -X THE PROBABILITY SPACE IS OVER THE RANDOMNESS OF THE FILTER AND DOES NOT DEPEND ON THE SET S OR THE QUERIED KEY X.
utt_0011 utt 63.60 66.32 -X LET’S COMPARE A FILTER WITH A DICTIONARY.
utt_0012 utt 66.32 69.87 -X A DICTIONARY ANSWERS QUERIES PRECISELY WITHOUT ANY ERRORS
utt_0013 utt 70.03 80.34 -X HOWEVER, STORING AN EXACT REPRESENTATION OF S, REQUIRES AT LEAST LOG U OVER S BITS PER ITEM, WHERE U IS THE UNIVERSE AND S IS THE SET.
utt_0014 utt 81.23 87.54 -X THE HIGH SPACE CONSUMPTION OF A DICTIONARY IMPLIES THAT A DICTIONARY DOES NOT FIT IN THE MAIN MEMORY IF THE SET IS LARGE.
utt_0015 utt 88.75 94.07 -X FILTERS HOWEVER, REQUIRE ONLY BIG-O OF LOG ONE OVER Ε BITS PER ITEM.
utt_0016 utt 95.41 99.76 -X SO IF WE USE A FILTER, AND WE ALLOW A FALSE-POSITIVE RATE OF one%
utt_0017 utt 99.76 105.59 -X THEN EACH ITEM REQUIRES ONLY twelve BITS REGARDLESS OF THE UNIVERSE SIZE OR THE SIZE OF THE SET.
utt_0018 utt 110.67 115.86 -X FILTER’S API CONSISTS OF TWO PARTS. INSTANTIATION, AND OPERATIONS.
utt_0019 utt 115.86 121.78 -X A FILTER NEEDS three PARAMETERS TO BE INSTANTIATED. A SPECIFICATION OF A UNIVERSE, DENOTED BY U
utt_0020 utt 122.06 124.98 -X AN UPPER BOUND N ON THE SIZE OF THE SET S,
utt_0021 utt 124.98 133.30 -X AND AN UPPER BOUND Ε ON THE DESIRED FALSE POSITIVE PROBABILITY A FILTER SUPPORTS THE FOLLOWING OPERATIONS:
utt_0023 utt 133.62 138.29 -X “QUERY X”: WHICH IS A MEMBERSHIP QUERY FOR AN ITEM X FROM THE UNIVERSE U,
utt_0024 utt 138.38 145.65 -X “INSERT X”: WHICH ADDS X INTO THE SET S AND “DELETE X” WHICH REMOVES X FROM THE SET S
utt_0026 utt 149.68 157.27 -X IN THIS TALK, I WILL FOCUS ON INCREMENTAL FILTERS, THAT SUPPORT ONLY INSERTIONS AND QUERIES, BUT DO NOT SUPPORT DELETIONS.
utt_0028 utt 158.06 169.37 -X INCREMENTAL FILTERS ARE USEFUL IN MANY APPLICATIONS. ONE SUCH APPLICATION IS LSM TREES THAT EMPLOY FILTERS TO REDUCE REDUNDANT I/O’S, NAMELY, SEARCHES FOR ITEMS THAT ARE NOT STORED ON DISK.
utt_0030 utt 169.94 178.29 -X TO THIS END, WE CREATE A FILTER FOR THE SET OF KEYS IN EACH SSTABLE BEFORE ACCESSING AN SSTABLE, WE QUERY THE FILTER.
utt_0032 utt 178.74 180.15 -X IF THE FILTER SAYS “NO”
utt_0033 utt 181.11 186.07 -X THEN WE SAVE THE ACCESS TO THE SSTABLE AND THE I/O ASSOCIATED WITH THE ACCCESS.
utt_0034 utt 189.11 196.09 -X IT IS IMPORTANT TO NOTE THAT A FILTER SAVES I/OS ONLY FOR QUERIES ON WHICH THE FILTER RESPONDS WITH “NO”.
utt_0036 utt 196.40 209.53 -X WE CALL THOSE “NO-QUERIES”. AS SHOWN IN THE BOTTOM FIGURE, FILTERS SAVE I/O’S ONLYFOR NO-QUERIES.
utt_0037 utt 209.53 212.31 -X A DREAM INCREMENTAL FILTER SIMULTANEOUSLY ACHIEVES:
utt_0038 utt 212.98 217.24 -X FAST BUILD TIME, FAST NO-QUERIES, AND LOW SPACE OVERHEAD.
utt_0039 utt 218.99 220.47 -X AND LOW SPACE OVERHEAD.
utt_0040 utt 220.47 223.45 -X CURRENT FILTERS SUPPORT ONLY TWO OUT OF THOSE THREE PROPERTIES.
utt_0041 utt 223.45 226.97 -X FOR EXAMPLE: BLOOM-FILTER HAS MULTIPLICATIVE SPACE OVERHEAD.
utt_0042 utt 227.12 229.78 -X CUCKOO-FILTER HAS SLOW BUILD TIME.
utt_0043 utt 229.78 234.71 -X AND THE VECTOR-QUOTIENT-FILTER HAS RELATIVELY SLOWER NO-QUERIES.
utt_0044 utt 240.50 243.64 -X OUR PREFIX-FILTER IS BUILD UPON TWO KEY IDEAS.
utt_0045 utt 243.64 250.81 -X THE FIRST ONE IS TO USE “FINGERPRINTS”, WHICH IS A POPULAR TECHNIQUE USED BY BOTH CUCKOO-FILTER, VECTOR-QUOTIENT-FILTER AND OTHERS.
utt_0047 utt 251.60 260.12 -X AT A HIGH LEVEL, INSTEAD OF STORING THE ITEMS OF THE SET S, WE HASH THE UNIVERSE U INTO A SMALLER UNIVERSE OF SIZE N OVER Ε.
utt_0049 utt 260.12 265.43 -X THE IMAGE OF X UNDER THE HASH FUNCTION IS CALLED THE FINGERPRINT OF X.
utt_0050 utt 266.07 270.78 -X WE THEN STORE FINGERPRINTS OF ITEMS IN THE SET S IN A HASH TABLE.
utt_0051 utt 271.22 278.01 -X WE NOTE THAT FALSE-POSITIVE ERRORS ARE CAUSED ONLY BY COLLISIONS INTRODUCED BY THE HASHING.
utt_0052 utt 278.10 282.84 -X TWO IMPORTANT GOALS IN THE DESIGN OF FILTERS BASED ON HASHTABLES OF FINGERPRINTS ARE:
utt_0053 utt 282.87 287.61 -X SMALL SPACE AND FEW MEMORY ACCESSES PER OPERATION.
utt_0054 utt 289.17 291.67 -X CURRENT FINGERPRINT BASED FILTERS ARE:
utt_0055 utt 291.67 298.26 -X CUCKOO-FILTER THAT BUILDS ON “CUCKOO HASHING” AND VECTOR-QUOTIENT-FILTER THAT USES THE-POWER-OF-TWO-CHOICES SCHEME
utt_0057 utt 299.28 303.55 -X BOTH MUST PERFORM TWO MEMORY ACCESSES PER NO-QUERY.
utt_0058 utt 303.67 307.48 -X OUR GOAL IS TO REDUCE THE NUMBER OF MEMORY ACCESS PER NO-QUERIES TO one.
utt_0059 utt 307.48 320.79 -X I WILL NOW PRESENT THE PREFIX FILTER THE PREFIX-FILTER USES A LOAD BALANCING DESIGN, BASED ON TWO LEVELS THAT ENABLES BOTH FAST INSERTIONS AND QUERIES.
utt_0062 utt 322.68 324.57 -X EACH LEVEL STORES FINGERPRINTS.
utt_0063 utt 324.57 328.86 -X THE FIRST LEVEL, CALLED THE BIN TABLE, IS AN ARRAY OF M BINS
utt_0064 utt 329.30 330.65 -X EACH OF CAPACITY K.
utt_0065 utt 331.45 333.63 -X KEYS ARE RANDOMLY HASHED TO THE BINS.
utt_0066 utt 335.03 338.65 -X THE BIN TABLE OF THE FIRST LEVEL STORES MOST OF THE FINGERPRINTS.
utt_0067 utt 338.65 352.09 -X THE SECOND LEVEL, CALLED THE SPARE, IS AN INCREMENTAL FILTER THAT STORES THE FINGERPRINTS WHOSE BINS IN THE FIRST LEVEL ARE FULL.
utt_0069 utt 352.09 360.63 -X EACH BIN IS A DICTIONARY THAT IMPLEMENTS A DATA STRUCTURE CALLED A POCKET DICTIONARY (PD), INTRODUCED BY [BERCEA AND EVEN, two thousand and nineteen].
utt_0070 utt 360.63 365.85 -X A PD EMPLOYS THE FANO-ELIAS ENCODING [FANO, one thousand, nine hundred and seventy-one, ELIAS, one thousand, nine hundred and seventy-four]
utt_0071 utt 366.42 369.18 -X FOR EXAMPLE, A PD CAN STORE twenty-five UMBERS USING twenty-five6 BITS,
utt_0072 utt 370.46 375.64 -X SAVING twenty% OF THE SPACE COMPARED TO THE EXPLICIT REPRESENTATION.
utt_0073 utt 375.64 380.73 -X ONE OF OUR CONTRIBUTIONS, IS AN EFFICIENT PD IMPLEMENTATION USING SIMD INSTRUCTIONS
utt_0074 utt 380.89 384.57 -X DETAILS APPEAR IN THE PAPER.
utt_0075 utt 384.63 388.99 -X WE FIRST FOCUS ON THE FIRST LEVEL OF THE PREFIX-FILTER.
utt_0076 utt 389.40 392.48 -X LET UPPERCASE FP(X) DENOTE THE FINGERPRINT OF X.
utt_0077 utt 393.02 397.15 -X WE INTERPRET UPPERCASE FP(X) AS TWO HASH FUNCTIONS:
utt_0078 utt 397.30 399.64 -X BIN OF X AND LOWERCASE FP OF X.
utt_0079 utt 401.69 404.67 -X BIN OF X MAPS X TO ONE OF THE BINS.
utt_0080 utt 405.40 409.66 -X WE REFER TO LOWERCASE F P(X) AS THE MINI-FINGERPRINT OF X.
utt_0081 utt 410.65 416.25 -X AT A HIGH LEVEL, THE BIN TABLE ATTEMPTS TO STORE THE MINI-FP OF X IN BIN OF X.
utt_0082 utt 420.79 427.32 -X OUR MAIN CONTRIBUTION IS THE PREFIX INVARIANT FROM WHICH THE NAME PREFIX FILTER IS DERIVED.
utt_0083 utt 427.83 436.16 -X THIS INVARIANT ENABLES ninety-two% OF THE OPERATIONS TO COMPLETE WITH ONE SINGLE MEMORY ACCESS.
utt_0084 utt 436.16 440.70 -X WHEN A KEY X IS INSERTED, WE ADD ITS MINI-FINGERPRINT TO BIN(X).
utt_0085 utt 441.72 447.87 -X IF BIN(X) OVERFLOWS, WE FORWARD ONE FINGERPRINT FROM IT, TO THE SPARE.
utt_0087 utt 447.87 451.20 -X WHICH FINGERPRINT FROM BIN(X) IS FORWARDED TO THE SPARE?
utt_0088 utt 451.20 454.27 -X A NAIVE SOLUTION, IS TO FORWARD THE NEWLY INSERTED FINGERPRINT.
utt_0089 utt 454.27 455.36 -X WHICH IS FP(X)
utt_0090 utt 457.98 465.53 -X OUR KEY INSIGHT IS TO FORWARD THE LARGEST MINI-FINGERPRINT SO THAT THE BIN CONTAINS A MAXIMAL PREFIX OF THE SMALLEST MINI-FINGERPRINTS
utt_0092 utt 467.16 471.17 -X TO SEE THE BENFIT GENERATED BY THE PREFIX INVARIANT CONSIDER A NO-QUERY.
utt_0094 utt 471.17 477.60 -X THE NAIVE APPROACH REQUIRES SEARCHING FOR X IN BOTH LEVELS IF BIN(X) OVERFLOWED.
utt_0095 utt 477.60 487.33 -X THE PREFIX INVARIANT REQUIRES SEARCHING THE SPARE ONLY IF BIN(X) OVERFLOWED AND AND THE MINI-FINGERPRINT OF X IS LARGER THAN ALL MINI-FINGERPRINTS CURRENTLY STORED IN BIN(X)
utt_0097 utt 487.33 491.97 -X THIS DRAMATICALLY CUTS DOWN THE NUMBER OF ACCESS TO THE SPARE
utt_0098 utt 492.12 502.72 -X SPECIFICALLY, WE PROVE THAT LESS THAN eight% OF THE NO-QUERIES NEED TO ACCESS THE SPARE.
utt_0099 utt 502.72 507.39 -X ANOTHER CONTRIBUTION OF OUR WORK IS THE MATHEMATICAL ANALYSIS OF THE PREFIX-FILTER.
utt_0100 utt 507.39 513.95 -X WE RIGOROUSLY BOUND THE FILTER’S FALSE POSITIVE RATE, AND PROBABILITY THAT AN OPERATION REQUIRES ACCESSING THE SPARE,
utt_0102 utt 513.95 516.19 -X AND HENCE MORE THAN A SINGLE MEMORY ACCESS.
utt_0103 utt 516.64 519.65 -X IMPORTANTLY, OUR ANALYSIS ISN’T ASYMPTOTIC,
utt_0104 utt 519.87 524.16 -X SO IT DOESN’T HIDE CONSTANTS, AND WORKS FOR PRACTICAL VALUES OF THE SET-SIZE N.
utt_0105 utt 525.44 529.70 -X OUR ANALYSIS STUDIES X, THE NUMBER OF FINGERPRINTS FORWARDED TO THE SPARE.
utt_0106 utt 530.97 534.14 -X WE PROVIDE AN EXACT EXPRESSION FOR THE EXPECTATION OF X,
utt_0107 utt 535.26 539.07 -X AND ALSO SHOW THAT X IS HIGHLY CONCENTRATED AROUND ITS EXPECTATION
utt_0108 utt 539.96 544.16 -X THIS ALLOWS US TO BOUND THE EVENT THAT “TOO MANY” FINGERPRINTS ARE FORWARDED TO THE SPARE
utt_0109 utt 544.76 550.11 -X AND FROM THAT THE PROBABILITY THAT AN OPERATION WILL ACCESS THE SPARE.
utt_0110 utt 550.30 554.18 -X I WILL NOW PRESENT AN EMPIRICAL EVALUATION OF THE PREFIX-FILTER.
utt_0111 utt 554.78 558.98 -X WE START WITH AN EXPERIMENT THAT EVALUATES FILTERS UNDER VARYING LOADS.
utt_0112 utt 559.48 564.03 -X WE INITIALIZE THE FILTERS TO SUPPORT A SET WITH ROUGHLY two hundred and fifty MILLION KEYS.
utt_0113 utt 566.43 569.95 -X THE EXPERIMENT THEN PROCEEDS BY GRADUALLY INSERTING THE KEYS
utt_0114 utt 570.49 574.82 -X IN INCREMENTS OF five% AND MEASURING THE INSERTION THROUGHPUT AS LOAD INCREASES
utt_0115 utt 575.55 581.28 -X AFTER LOADING EACH five% OF THE KEYS, WE MEASURE THE THROUGHPUT OF UNIFORMLY RANDOM QUERIES AT THIS LOAD.
utt_0117 utt 581.95 586.18 -X DUE TO THE UNIVERSE SIZE, UNIFORM QUERIES ARE IN FACT NO QUERIES.
utt_0118 utt 586.72 590.40 -X FINALLY, WE MEASURE THE THROUGHPUT OF YES QUERIES AT THIS LOAD.
utt_0119 utt 591.29 595.52 -X WE EVALUATE AND COMPARE THE PREFIX-FILTER TO THE BLOOM FILTER THE CUCKOO FILTER,
utt_0121 utt 597.12 604.45 -X AND AN IMPLEMENTATION OF VQF USING OUR IMPROVED PD STRUCTURE, WHICH WE CALL ‘TWO-CHOICER’.
utt_0122 utt 605.73 609.06 -X ‘TWO-CHOICER’ HAS twenty-six% HIGHER NO-QUERY THROUGHPUT THAN VQF
utt_0123 utt 609.09 612.19 -X WHICH IS WHY WE USE IT.
utt_0124 utt 612.19 618.75 -X WE NOTE THAT SINCE THE SPARE IS IN FACT A FILTER, WE ALSO USE A TWO-CHOICER AS THE SPARE IN THE PREFIX-FILTER.
utt_0125 utt 621.82 625.35 -X AFTER EXPLAINING THE EXPERIMENT SETTINGS, WE MOVE ON TO THE RESULTS.
utt_0126 utt 625.66 629.70 -X THE BLOOM-FILTER EXPECTED NUMBER OF PROBES INCREASES AS THE FILTERS FILLS UP
utt_0127 utt 629.95 633.60 -X UPTO ROUGHLY two MEMORY ACCESSES PER QUERY IN EXPECTATION
utt_0128 utt 633.85 636.42 -X MAKING THE BLOOM-FILTER SLOWEST FOR NO-QUERIES.
utt_0129 utt 636.83 643.33 -X THE CUCKOO-FILTER’S NO-QUERY THROUGHPUT IS STEADY, AS IT ALWAYS PERFORMS THE SAME COMPUTATIONS PER QUERY.
utt_0130 utt 643.33 647.01 -X IT ALSO HAS THE FASTEST POSITIVE-QUERIES THROUGHPUT.
utt_0131 utt 647.23 651.43 -X THE NO-QUERY THROUGHPUT OF THE TWO-CHOICER DECLINES BY thirty-one% AS IT FILLS-UP.
utt_0132 utt 651.78 656.58 -X THE PREFIX-FILTER HAS THE FASTEST NO-QUERY THROUGHPUT.
utt_0133 utt 656.58 664.20 -X THE NO-QUERY THROUGHPUT OF THE PREFIX-FILTER DECLINES BY forty-six% AS IT FILLS-UP.
utt_0134 utt 664.93 671.24 -X HERE WE SHOW THAT THE TIME REQUIRED TO POPULATE AN EMPTY FILTER WITH ROUGHLY two hundred and fifty MILLION KEYS.
utt_0135 utt 671.71 674.66 -X THE PREFIX-FILTER HAS THE FASTEST BUILD TIME.
utt_0136 utt 674.66 678.63 -X THE PREFIX-FILTER IS two point three four TIMES FASTER THAN BLOOM-FILTER
utt_0137 utt 679.33 681.22 -X three point six TIMES FASTER THAN CUCKOO-FILTER
utt_0138 utt 682.56 685.44 -X one point four TIMES FASTER THAN TWO-CHOICER.
utt_0139 utt 685.60 688.93 -X TO SUMMARIZE, WE PROPOSE THE PREFIX-FILTER
utt_0140 utt 688.99 691.56 -X AN INCREMENTAL FILTER THAT OFFERS:
utt_0141 utt 691.56 695.08 -X SPACE EFFICIENCY COMPARABLE TO STATE-OF-THE-ART FILTERS
utt_0142 utt 695.14 698.50 -X FAST QUERIES, COMPARABLE TO THOSE OF THE CUCKOO FILTER
utt_0143 utt 698.94 704.16 -X FAST INSERTIONS, WITH OVERALL BUILD TIMES FASTER THAN THOSE OF THE VECTOR QUOTIENT FILTER AND CUCKOO FILTER
utt_0144 utt 705.06 710.07 -X RIGOROUS ANALYSIS OF THE PREFIX FILTER’S PROPERTIES THAT HOLDS EVEN FOR PRACTICAL VALUES
utt_0145 utt 710.63 715.43 -X WE ALSO EMPIRICALLY EVALUATE THE PREFIX FILTER AND DEMONSTRATE ITS QUALITIES IN PRACTICE
utt_0146 utt 716.13 720.13 -X A PUBLIC IMPLEMENTATION OF THE PREFIX-FILTER IN C++ IS AVAILABLE AT GITHUB
utt_0147 utt 721.47 723.21 -X AT THE FOLLOWING URL.
utt_0148 utt 724.67 728.74 -3.6669 THANK YOU VERY MUCH FOR YOUR ATTENTION!
