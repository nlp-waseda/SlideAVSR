utt_0000 utt 3.15 8.59 -X HI EVERYBODY AND THANKS FOR JOINING MY TALK ON INVALIDB, SCALABLE PUSH-BASED REAL-
utt_0001 utt 8.59 20.50 -X TIME QUERIES ON TOP OF PULLED-BASED DATABASES. I'M WOLLE FROM THE GERMAN COMPANY BAQEND AND TODAY'S TALK WILL BE ABOUT INVALIDB WHICH IS THE SYSTEM THAT WE'VE DEVELOPED AT BAQEND TO PROVIDE SCALABLE REAL-TIME QUERIES.
utt_0004 utt 21.64 34.32 -X THIS TALK WILL BE DIVIDED INTO FOUR MAJOR PARTS. THE FIRST ONE IS THE INTRODUCTION WHERE WE TALK ABOUT THE ACTUAL PROBLEM WE'RE TRYING TO SOLVE HERE AND WHY IT'S DIFFICULT TO PROVIDE REAL-TIME QUERIES TO BEGIN WITH THEN WE'LL TALK ABOUT
utt_0007 utt 34.32 47.63 -X RELATED WORK SO THAT MEANS WE'LL TALK ABOUT OTHER APPROACHES FOR PROVIDING REAL-TIME CREES AND WE'LL UNCOVER WHAT THE ISSUES WITH THESE APPROACHES ARE IN THE THIRD PART WILL TALK ABOUT IN VALUE B'S DESIGN SO WE'LL EXPLAIN WHAT WE ARE
utt_0010 utt 47.63 52.11 -X MAKING DIFFERENT AND IN THE FOURTH PART WE'LL DISCUSS APPLICATIONS OF OUR DESIGN
utt_0011 utt 52.88 55.31 -X AND WE'LL TALK ABOUT WHAT WE'RE PLANNING NEXT
utt_0012 utt 56.91 71.20 -X OKAY SO LET'S START WITH TRADITIONAL DATABASES AND FRILL ASTRAY SSIN LET'S TALK ABOUT A REAL-TIME APPLICATION THAT DISPLAYS BASICALLY THE DATA THAT IS IN THE DATABASE AND PROVIDES REAL-TIME UPDATES SO CONSIDER IT A SIMPLE TOKEN
utt_0015 utt 71.20 85.01 -X APPLICATION THAT ONLY DISPLAYS ALL OF THE CIRCULAR SHAPES IN YOUR DATABASE AND THEN JUST THINK OF A DATABASE AS STORAGE OF DIFFERENT SHAPES SO THINGS GET WRITTEN TO THE DATABASE AND WHEN THE APPLICATION STARTS IT DISPLAYS THE
utt_0018 utt 85.01 96.31 -X CURRENT STATE SO CURRENTLY THERE ARE NO CIRCULAR SHAPES AND WE DON'T SEE ANY OF THEM IN THE USER INTERFACE BUT OVER TIME WE GET EVENTUALLY LIKE THIS BLUE BUBBLE
utt_0020 utt 96.31 109.36 -X THERE AND I WANT TO REFRESH THE USER INTERFACE THEN WE ALSO GET AN UPDATE BUT THE THING IS THAT SOMETIMES THINGS GET WRITTEN AND THE APPLICATION IS NOT REFRESHED AND THEN WE HAVE A DIVERGENCE BETWEEN DATABASE STATE AND APPLICATION
utt_0023 utt 109.36 124.12 -X STATE BECAUSE THE APPLICATION HAS TO EXPLICITLY ASK THE DATABASE FOR THE CHANGE OR BASICALLY THE CURRENT STATE AND WHEN IT DOES THAT IT GETS THE STATE BUT IN A VERY INEFFICIENT AND SLOW WAY BECAUSE EVERYTHING IS SENT FROM THE
utt_0026 utt 124.12 137.56 -X DATABASE TO THE APPLICATION EVEN IF PART OF THE STATE LIKE THE BLUE BUBBLE HERE IS ALREADY KNOWN AT THE CLIENT AND IT'S VERY SLOW BECAUSE THE APPLICATION HAS TO ASK FOR CHANGES AND IF THE APPLICATION FOR EXAMPLE ONLY PULLS ONCE A MINUTE
utt_0029 utt 137.56 139.80 -X THEN YOU HAVE A ONE MINUTE STAY ON THIS WINDOW THERE
utt_0030 utt 141.68 152.95 -X WHAT YOU ACTUALLY WANT TO HAVE IN THIS KIND OF APPLICATION IS A REAL-TIME DATABASE AS A STORAGE BACK-END SO IN THIS CASE THE APPLICATION DOESN'T JUST
utt_0032 utt 152.95 164.60 -X FIRE UP A QUERY INITIALLY BUT ESTABLISHES A PERSISTENT CONNECTION SO THAT THE DATABASE KNOWS OKAY THIS IS THE KIND OF QUERY THAT I NEED TO KEEP UP-TO-DATE AND WHENEVER THERE IS SOMETHING RELEVANT TO THE QUERY RESULTS
utt_0035 utt 165.17 178.10 -X SO NAMELY CIRCULAR SHAPES AND THE DATABASE JUST TRANSMITS THEM IMMEDIATELY AND WITHOUT ANY DELAY SO THAT IS JUST VERY EFFICIENT BECAUSE IT DOESN'T TRANSMIT THE SAME DATA TWICE WITHOUT A GOOD REASON AND IT'S ALSO VERY FAST
utt_0038 utt 178.10 192.45 -X BECAUSE UPDATES ARE TRANSMITTED IMMEDIATELY THE PROBLEM WITH REAL-TIME QUERIES IS THAT THEY ARE VERY RESOURCE INTENSIVE TO PROVIDE SO JUST IMAGINE YOU HAVE A SINGLE REAL-TIME QUERY AND NOW YOU HAVE A SINGLE UPDATE OPERATION
utt_0041 utt 192.45 206.36 -X HITTING YOUR DATABASE AND YOU NEED TO CONSIDER OK THE ANTE THE ITEM THAT WAS UPDATED IS THE MATCH TO THE QUERY NOW AND DID IT MATCH THE QUERY BEFORE THE UPDATE OCCURRED AND JUDGING BY THESE POINTS OF INFORMATION YOU HAVE TO DEDUCT
utt_0044 utt 206.36 219.59 -X WHETHER THE RESULT CHANGED OR WHETHER AN ITEM WAS ADDED OR WHETHER AN ITEM WAS REMOVED AND DEPENDING ON THE NUMBER OF QUERIES THAT ARE CURRENTLY ACTIVE AND THE WRITE THROUGHPUT AND THE QUERY COMPLEXITY MATCHING EVERY QUERY AGAINST
utt_0047 utt 219.59 231.77 -X EVERY INCOMING UPDATE OPERATION CAN JUST BECOME PROHIBITIVE AND THAT'S THE REASON WHY TRIGGERS OR EVENT CONDITION ACTION RULES AND MATERIALIZED VIEWS ARE ALSO VERY EXPENSIVE TO PROVIDE FOR A DATABASE SYSTEM
utt_0050 utt 233.40 243.94 -X OKAY SO NOW WE'VE SET THE SCENE FOR WHAT REAL COUNTRY IS AND WHY IT'S DIFFICULT TO PROVIDE LET'S TALK ABOUT HOW CURRENT TECHNOLOGY IS ADDRESSING THIS PROBLEM
utt_0052 utt 245.17 257.72 -X THERE ARE TWO PREVALENT MECHANISMS FOR PROVIDING REAL-TIME QUERIES ONE OF THEM IS CALLED POLLEN TIP AND THE NAME ALREADY TELLS YOU WHAT IT DOES SO IN THE EXAMPLE HERE WE HAVE DIFFERENT APPLICATION SERVERS AND DIFFERENT USERS
utt_0055 utt 257.72 270.97 -X AND THE USERS SUBSCRIBE FOR REAL-TIME QUERIES AT THE APPLICATION SERVICE SO WHENEVER AN APPLICATION SERVER RECEIVES THE RIGHT OPERATION IT WRITES THAT OFF TO THE DATABASE AND ALSO CHECKS WHETHER ANY OF THE QUERY SUBSCRIPTION THAT THE
utt_0058 utt 270.97 281.83 -X SERVER ITSELF HANDLES IS LIKE AFFECTED BY THIS RIGHT OPERATION AND IF SO IT SENDS OUT THE CHANGE NOTIFICATION THIS THIS IS PRETTY SIMPLE BUT THE PROBLEM IS
utt_0060 utt 281.83 296.15 -X THAT SOMETIMES THE SERVER ON THE RIGHT WILL RECEIVE A WRITE OPERATION AND THE SERVER ON THE LEFT DOESN'T REALLY KNOW THAT THAT HAPPENED SO TO DISCOVER CHANGES THAT ARE WRITTEN BY OTHER SERVERS IT PULLS THE QUERIES THAT ARE
utt_0063 utt 296.15 306.41 -X ACTIVE PERIODICALLY SO FOR EXAMPLE THE MEDIA OR DEFAULT IS ten SECONDS AND THEN IT GETS ALL THE RESULTS CHECKS WHETHER ANYTHING CHANGED TO THE LAST KNOWN
utt_0065 utt 306.41 316.31 -X RESULT REPRESENTATION AND SENDS OUT THE CHANGES ACCORDINGLY THIS WORKS FUNCTIONALLY BUT THE BIG PROBLEMS HERE ARE FIRST YOU HAVE A GIANT STAY ON THIS
utt_0067 utt 316.31 330.72 -X WINDOW SO IF YOU PULL EVERY ten SECONDS THEN YOUR RESULTS MIGHT BE LAGGY BY ten SECONDS AND YOU ALSO HAVE ABSOLUTELY NO REACH SCALABILITY BECAUSE IF YOU HAVE MANY CONCURRENT QUERIES SO MANY USERS EVEN IF NOTHING HAPPENS ON YOUR DATABASE
utt_0070 utt 330.72 334.99 -X THEN I'M YOUR SYSTEM WILL BE CLOBBERED TO DEATH WITH THESE POLLEN QUERIES
utt_0071 utt 336.70 350.88 -X BUT THAT'S ANOTHER APPROACH THAT AVOIDS THE PERIODIC POLLING AND THE BASIC IDEA CHANGED LOCKED AILING I ALSO TELLS YOU WHAT IT DOES SO THE IDEA IS THAT ALL THE APPLICATIONS SERVERS SUBSCRIBE TO THE ENTIRETY OF THE DATABASE CHANGE LOCK SO
utt_0074 utt 351.00 363.40 -X IF LIKE IN THE EXAMPLE EARLIER THE SERVER ON THE RIGHT RECEIVES A WRITE OPERATION IT WRITES IT OFF TO THE DATABASE AND THE OTHER SERVER DOESN'T HAVE TO PULL FOR CHANGES BECAUSE THE CHANGE IS DELIVERED WITH THE DATABASE
utt_0077 utt 363.40 376.96 -X CHANGE STREAM SO THE APP SERVER ESSENTIALLY PRETENDS TO BE A DATABASE REPLICA NOW THE OBSERVER ON THE LEFT HAS THE UPDATE CAN CHECK WHETHER ANY ANY CHANGES OCCURRED TO THE SUBSCRIBE CREASE AND IT CAN SEND OUT ALL THE
utt_0080 utt 376.96 390.85 -X NOTIFICATIONS AND THIS IS AWESOME BECAUSE IT LIKE AVOIDS THE LATENCY OVERHEAD OF POLLING AND ALSO AVOIDS THE READ SCALABILITY BOTTLENECK BUT THE PROBLEM IS THAT IF YOU REALLY NEED DATABASE SHARDING YOU KNOW THEN RIGHTS
utt_0083 utt 390.85 404.72 -X ARE DISTRIBUTED ON THE DATABASE LEVEL BUT THE THE CHANGELOG BROADCAST BECAUSE EVERY APP SERVER IS SUBSCRIBED TO ALL OF THE DATABASE CHARTS TO RECEIVE ALL THE CHANGES THIS BROADCAST WILL JUST BREAK YOUR APPLICATION BECAUSE YOU CANNOT
utt_0086 utt 404.72 415.93 -X EFFECTIVELY SHARD YOUR APPLICATION EVEN IF YOU'RE USING A CHARLOTTE DATABASE AND THAT'S A PROBLEM BECAUSE THIS ESSENTIALLY MEANS OR EFFECTIVELY MEANS THAT YOU HAVE NO RIGHT SCALABILITY WHATSOEVER
utt_0089 utt 417.31 427.49 -X AS YOU CAN SEE MOST SYSTEMS TODAY USE EITHER POLLEN DIP OR CHANGE LOOK TAILING FIRE BASE AND FIRESTAR ARE THE EXCEPTION AS THEY USE UNKNOWN PROPRIETARY
utt_0091 utt 427.49 440.19 -X APPROACHES BUT THE THE BOTTOM LINE OF THIS TABLE IS THAT NO SYSTEM PROVIDES SIMULTANEOUS READ/WRITE SCALABILITY IRRESPECTIVE OF THE APPROACH THAT THEY'RE USING AND THAT'S WHY WE DEVELOPED INVALID TO BE BECAUSE IN VALUE
utt_0094 utt 440.19 444.01 -X CAN PROVIDE READ AND WRITE SCALABILITY AT THE SAME TIME
utt_0095 utt 445.53 459.78 -X IN THE NEXT SECTION WE'LL TALK ABOUT THE IN VALUE SYSTEM MODEL SO HOW SUBSCRIPTIONS AND CHANGE NOTIFICATIONS WORK AND HOW THE MATCHING WORKLOAD IS DISTRIBUTED INTERNALLY TO ACHIEVE SIMULTANEOUS READ AND WRITE SCALABILITY
utt_0098 utt 461.76 475.52 -X WHEN A APPLICATION REGISTERS A REAL-TIME QUERY WITHIN VALLEY DB IT SENDS THE QUERY TO THE APP SERVER AND THE APP SERVER EXECUTES SIT ON THE POOL BASED DATABASE AND THE RESULT IS NOT GIVEN TO THE USER SO TO THE BROWSER FOR EXAMPLE
utt_0101 utt 475.52 489.41 -X BUT RATHER GIVEN TO THE INVALID DB CLUSTER SO IT'S SENT TO THE EVENT LAYER WHICH IS KIND OF A MESSAGE BROKER AND THEN WE HAVE THIS DISTRIBUTED CLUSTER OF NODES ON THE LEFT THAT JUST REGISTER STAYED AND WHEN EVERYTHING IS DONE AND
utt_0104 utt 489.41 503.52 -X READY IT SENDS OUT THE INITIAL RESULT FOR THE END USER JUST AS A SIGN THAT THIS SUBSCRIPTION IS READY NOW AND WHENEVER SOMETHING THAT'S WRITTEN COULD BE BINARY USER OR BY ANOTHER PROCESS COULD BE RECEIVED BY THE
utt_0107 utt 503.52 515.79 -X SAME APPLICATION SERVER OR BY A DIFFERENT ONE DOESN'T MATTER THIS RIGHT OPERATION IS APPLIED TO THE DATABASE AND ALSO GIVEN TO THE INVALID DB CLUSTER WHERE IT IS CHECKED AGAINST ALL CURRENTLY ACTIVE REAL-TIME QUERIES AND
utt_0110 utt 515.79 519.81 -X THEN ANY CHANGED DATA ADULT US ARE SENT OUT IF THERE ARE ANY
utt_0111 utt 520.86 532.11 -X SO THIS ARCHITECTURE HAS TWO BIG ADVANTAGES OVER THE OTHER APPROACHES DISCUSSED EARLIER ONE IS THAT REAL TIME AND OLTP WORKLOADS ARE DECOUPLED SO WE
utt_0113 utt 532.11 547.06 -X DON'T HAVE THE MATCHING WITHIN THE APPLICATION SERVER SO YOU KNOW AN OVERLOAD IN THE REAL TIME WORKLOAD CANNOT BRING DOWN THE APPLICATION SERVER THAT'S A BIG PRO AND ALSO WE CAN SCALE THE INVALUABLE CLUSTER JUST TO BEEF UP
utt_0116 utt 547.06 559.46 -X OUR REAL-TIME CAPABILITIES WHICH IS NOT POSSIBLE IF YOU HAVE ANYTHING ON EVERYTHING RUNNING ON THE APPLICATION SERVICE THEMSELVES AND ANOTHER BIG ADVANTAGE IS THAT SINCE ALL THE RESOURCES ARE COMPLETELY DECOUPLED
utt_0119 utt 559.46 569.73 -X THROUGH THE EVENT LAYER WE CAN EXPLOIT RESOURCE POOLING AND MULTI-TENANCY SO ADDING NEW CLIENTS IS VERY CHEAP AND WE STILL HAVE A BIG CLUSTER RUNNING BEHIND
utt_0121 utt 569.73 583.78 -X ALL THE CLIENTS TOGETHER WHICH GIVES US THE ABILITY TO BUFFER LOAD SPIKES AND SUCH BUT THE MAGIC OBVIOUSLY HAPPENS WITHIN THE INVALID EB CLUSTER SO JUST CONSIDER WE HAVE A COMPONENT FOR INGESTING
utt_0124 utt 583.78 597.06 -X QUERIES AND FOR INGESTING RIGHTS AND THEN WE HAVE A BUNCH OF NOTES THREE BY THREE IN THIS EXAMPLE FOR MATCHING QUERIES AGAINST WRITE OPERATIONS WHAT WE DO FIRST IS WE PARTITION ALL THE NODES INTO QUERY PARTITIONS AND WHEN A QUERY
utt_0127 utt 597.06 609.51 -X IS REGISTERED WE GIVE ALL THE NODES IN ONE OF THESE PARTITIONS THIS QUERY SO NOW A THREE NODES ARE RESPONSIBLE FOR KEEPING THIS QUERY UP-TO-DATE AND FOUR WRITES WE DO THE SAME SO WE PARTITION EVERYTHING INTO WRITE PARTITIONS AND
utt_0130 utt 609.51 621.56 -X WHEN SOMETHING IS WRITTEN WE DETERMINE THE WRITE PARTITION AND THEN GIVE THE WRITE OPERATION TO ALL THE NODES IN THAT PARTITION NOW YOU SEE THAT THERE IS AN OVERLAP BETWEEN ALL THE QUERY AND ALL THE WRITE PARTITIONS SO WHEN THERE IS A
utt_0133 utt 621.56 631.43 -X CHANGE TO BE DETECTED WE KNOW THAT ONE OF THE NODES WILL GENERATE AND SEND IT OUT BUT WE ALSO HAVE RESPONSIBILITIES OF ONLY ONE THREAD OF ALL QUERIES AND
utt_0135 utt 631.43 641.94 -X ONE-THIRD OF THE WRITE THROUGHPUT PER NODE SO NO NODE IS ACTUALLY RESPONSIBLE FOR ALL THE RIGHTS OF ALL THE QUERIES AND IF WE NEED FOR EXAMPLE TO SUPPORT
utt_0137 utt 641.94 656.23 -X MORE CONCRETE QUERIES WE CAN JUST ADD MORE QUERY PARTITIONS THERE ALL WE COULD INCREASE SUSTAINABLE THROUGH FOOT BY ADDING MORE WRITE PARTITION NODES SO THAT GIVES US SIMULTANEOUS READ AND WRITE SCALABILITY AND WHILE TALKING
utt_0140 utt 656.23 670.98 -X ABOUT THIS I DIDN'T ONCE MENTION THE QUERY ENGINE SO THAT'S WHY WE IMPLEMENTED IMPLEMENTED IT IN A PLUGGABLE WAY SO WE COULD CURRENTLY SUPPORT MOMMY-TO-BE AND THAT'S WHAT WE DO BUT WE COULD ALSO SUPPORT SQL FOR EXAMPLE THAT MAKES THE APPROACH VERY GENERIC
utt_0144 utt 672.29 682.84 -X WE IMPLEMENTED IN VALUE BE AT BACK-END AND WE USE THE DISTRIBUTED STREAM PROCESSING SYSTEM STORM FOR IMPLEMENTING THE DISTRIBUTED QUERY ENGINE BECAUSE
utt_0146 utt 682.84 696.14 -X IT'S JUST UNMATCHED IN TERMS OF LOW LATENCY JUST AS REDIS AND THAT'S WHY WE CHOSE RED AS FOR THE EVENT LAYER FOR COMMUNICATION BETWEEN APP SERVER AND INVALID DB CLUSTER AND WE IMPLEMENTED EVERYTHING WITH THE MONGODB DATABASE
utt_0149 utt 696.14 705.32 -X BECAUSE IT'S THE DATABASE UNDERNEATH BACK-END AND BECAUSE IT'S JUST A VERY EXPRESSIVE NO SEQUEL DATABASE IT JUST SHOWS REAL-TIME CREES CAN BE EXPRESSIVE
utt_0151 utt 707.40 719.43 -X OKAY NOW FINALLY LET'S DISCUSS APPLICATION SCENARIOS FOR OUR REAL-TIME DATABASE THERE ARE TWO MAIN USE CASES FOR REAL-TIME CRUISE AT BACK-END THE FIRST ONE IS PROVIDING THIS
utt_0154 utt 719.43 732.38 -X FUNCTIONALITY TO DEVELOPERS SO AS YOU CAN SEE HERE WE HAVE AN INTERFACE FOR POOL BASED QUERIES AND ONE FOR REAL-TIME QUERIES AND THEY ARE BOTH ESSENTIALLY THE SAME YOU JUST USE DIFFERENT KEYWORD HERE SO YOU HAVE YOUR QUERY OBJECT
utt_0157 utt 732.38 745.16 -X EXECUTE A QUERY FUNCTION AND PROVIDE A CALLBACK FUNCTION THAT IS CALLED WHENEVER THERE'S A RESULT AND FOR THE POOL BASED QUERY YOU KNOW IT'S JUST CALLED ONCE BECAUSE THERE ONLY IS A SINGLE RESULT AND FOR THE WRITTEN QUERY
utt_0160 utt 745.16 755.21 -X IT'S CALLED WHENEVER THE INITIAL RESULT IS RETURNED OR WHEN THERE IS AN UPDATE SO THIS IS A VERY EASY WAY TO EXECUTE AND CREATE REAL-TIME APPLICATIONS
utt_0162 utt 756.61 771.23 -X THE SECOND USE CASE IS CONSISTENT QUERY CACHING ESSENTIALLY FOR IMPROVING PERFORMANCE OF PULL BASED DATABASES BECAUSE INVALID DB WAS INITIALLY DESIGNED FOR INVALIDATING DATABASE QUERIES HENCE THE NAME AND WHAT WE DO
utt_0165 utt 771.23 781.47 -X HERE IS THAT WE MAKE EVEN COMPLEX DATABASE QUERIES CACHEABLE SO FOR EXAMPLE USER SEARCHES FOR PRODUCTS IN A WEB SHOP AND THEN DEPLOY AND VALIDLY BE
utt_0167 utt 781.47 791.55 -X TO DETECT WHETHER ANYTHING HAS BEEN ADDED OR CHANGED OR REMOVED IN ANY OF THE CURRENTLY CACHED DATABASE QUERIES AND IF THAT'S THE CASE WE JUST HAVE
utt_0169 utt 791.55 801.93 -X INVALID DB INVALIDATE ALL THE CACHES SO THAT LETS US CACHE THINGS THAT YOU WOULD NORMALLY NOT BE ABLE TO CACHE BECAUSE WE CAN TRACK WHETHER OR NOT THE RESULTS
utt_0171 utt 801.93 807.21 -X HAVE CHANGED OR NOT WE EVALUATED THE POTENTIAL GAINS OF THIS
utt_0172 utt 809.48 824.09 -X USE CASE IN OUR VLDB two thousand and seventeen PUBLICATION AND FOUND THAT BOTH LATENCY AND THROUGHPUT OF TRADITIONAL POOL BASED QUERIES CAN BE IMPROVED BY SEVERAL ORDERS OF MAGNITUDES HERE YEAH TO SUM EVERYTHING UP WE'VE SEEN THAT
utt_0175 utt 824.09 838.72 -X TRADITIONAL POOL BASED DATABASES ARE NOT THE BEST CHOICE FOR REACTIVE OR REAL-TIME APPLICATIONS BECAUSE THEY REQUIRE YOU TO EXECUTE THE SAME QUERY OVER AND OVER WHICH IS BOTH INEFFICIENT AND PRETTY LAGGY AND NOW WE'VE SEEN THAT
utt_0178 utt 838.72 852.64 -X PUSH BASED REAL-TIME QUERIES WITH A NULL DB ARE MORE EFFICIENT BECAUSE THEY ENABLE YOU TO JUST SPECIFY YOUR QUERY THEN KEEP THE PERSISTENT DATABASE CONNECTION OPEN AND RECEIVE CHANGES WHENEVER THEY HAPPEN SO FIRST YOU HAVE A
utt_0181 utt 852.64 867.47 -X CONTINUOUS STREAM OF UPDATES HERE THEN OUR APPROACH IS LEGACY COMPATIBLE SO WE CAN MAKE IT WORK WITH YOUR APPLICATION STACK EVEN WHEN IT IS BUILT ON TOP OF A TRADITIONAL POOL BASED DATABASE IT'S VERY SCALABLE AND FAST AND OUR
utt_0184 utt 867.72 878.53 -X EXPRESSIVENESS IS ROUGHLY THAT OF MONGODB SO IT'S ESSENTIALLY NO SEQUEL CAPABLE OK AND IT'S VERY DEVELOPER FRIENDLY BECAUSE YOU CAN JUST USE THE
utt_0186 utt 878.53 889.10 -X SAME QUERY SEMANTICS FOR BOTH THE POOL AND PUSH-BASED CRUZ YEAH THAT BASICALLY CONCLUDES MY TALK THANKS FOR YOUR ATTENTION AND IF YOU HAVE QUESTIONS OR
utt_0188 utt 889.10 893.90 -3.0105 COMMENTS PLEASE DROP US A LINE AT VOLLEY AT BECKONED COMM THANKS VERY MUCH
