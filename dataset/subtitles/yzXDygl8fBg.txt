utt_0000 utt 0.16 11.23 -X HI, MY NAME IS AXEL HERTZSCHUCH AND I'M HAPPY TO PRESENT OUR PAPER TURBO-CHARGING SPJ QUERY PLANS WITH LEARNED PHYSICAL JOIN OPERATOR SELECTIONS. THIS IS JOINT WORK WITH CLAUDIO HARTMANN, DIRK
utt_0002 utt 11.23 25.87 -X HABICH, AND WOLFGANG LEHNER. OUR PAPER IS ABOUT QUERY OPTIMIZATION AND IN PARTICULAR PHYSICAL JOIN OPERATOR SELECTION FOR ARBITRARY SELECT PROJECT JOIN QUERY PATTERNS. NOW TO UNDERSTAND
utt_0004 utt 25.87 39.17 -X OUR FOCUS ON OPERATOR SELECTION WE FIRST HAVE TO SHED LIGHT ON THE OPERATOR SELECTION QUALITY FOR STATE-OF-THE-ART SYSTEMS FOR INSTANCE POSTGRESQL WHICH FOLLOWS A STANDARD TEXTBOOK APPROACH WHERE
utt_0006 utt 39.17 46.00 -X PHYSICAL JOIN OPERATOR SELECTION AND LOGICAL JOIN ORDERING RELIES ON CARDINALITY ESTIMATES.
utt_0007 utt 46.45 50.61 -X ON THE LEFT SIDE, YOU SEE THE JOIN ORDER BENCHMARK EXECUTION TIME
utt_0008 utt 50.99 64.05 -X OF A VANILLA POSTGRES INSTANCE AND IN PARTICULAR, WE FOUND OUT THAT POSTGRES USES A BALANCED MIXTURE OF INDEX NESTED LOOP JOINS AND HASH JOINS TO EXECUTE THE NATIVE QUERY PLANS
utt_0010 utt 65.81 71.06 -X NOW TO PUT THE OPERATOR SELECTION OF THE NATIVE PLANS INTO PERSPECTIVE,
utt_0011 utt 71.18 78.26 -X WE RESTRICT POSTGRES TO EXECUTE THE PREVIOUS JOIN ORDERS WITH HASH JOINS ONLY, AND AS CAN BE SEEN
utt_0012 utt 78.38 83.57 -X THE INCREASED QUERY RESPONSE TIME OF THE HASH JOIN RESTRICTED PLAN EQUIVALENT
utt_0013 utt 83.70 92.05 -X INDICATES THAT POSTGRES DOES ACTUALLY A DECENT JOB IN SELECTING PHYSICAL JOIN OPERATORS.
utt_0014 utt 92.05 105.43 -X HOWEVER, THE QUESTION REMAINS WHETHER WE CAN DO EVEN BETTER. THEREFORE IN OUR THIRD EXPERIMENT WE EXHAUSTIVELY ENUMERATED AND EXECUTED ALL JOIN OPERATOR COMBINATIONS FOR THE PREVIOUS JOIN ORDERS
utt_0016 utt 105.87 112.45 -X AND AS CAN BE SEEN SELECTING THE SINGLE BEST PHYSICAL JOIN OPERATOR FOR EACH JOIN REVEALS
utt_0017 utt 112.45 121.41 -X A HUGE POTENTIAL FOR OPTIMIZATION. TO LIFT THIS POTENTIAL WE PROPOSE TONIC IN OUR PAPER. TONIC
utt_0018 utt 121.41 127.78 -X IS A WHITE BOX LEARNING APPROACH BUILT ON TOP OF A GENERIC QUERY OPTIMIZER AND AS WILL BE SHOWN
utt_0019 utt 127.79 134.84 -X DURING THE PRESENTATION AND IN THE PAPER TONIC ACHIEVES CLOTHES TO OPTIMAL OPERATOR SELECTIONS.
utt_0020 utt 136.82 151.16 -X THE FOUNDATION OF TONIC IS THE SO-CALLED CASE-BASED REASONING LEARNING PARADIGM OR CBR IN SHORT. CBR IS AN ESTABLISHED PSYCHOLOGICAL THEORY IN THE FIELD OF HUMAN KNOWLEDGE ACQUISITION
utt_0022 utt 151.63 158.36 -X AND ACCORDING TO CBR KNOWLEDGE IS ORGANIZED IN BLUEPRINTS THAT ARE CALLED CASES.
utt_0023 utt 159.03 166.93 -X CASES ARE BASICALLY MEMORIZED PROBLEMS AND THEIR SOLUTION. NOW THE MAIN WORKHORSE OF CBR
utt_0024 utt 166.93 181.62 -X IS CASE REUSING WHERE NEW PROBLEMS ARE MATCHED WITH KNOWN CASES TO GENERATE NEW SOLUTIONS AND THESE SOLUTIONS ARE THEN REFINED BY EXTERNAL FEEDBACK AND STORED AS NEW CASES IN THE CASE BASE.
utt_0026 utt 183.28 190.02 -X NEXT, WE NEED TO MAP THE CORE PRINCIPLES OF CBR TO PHYSICAL OPERATOR SELECTION
utt_0027 utt 190.39 196.66 -X AND AS CAN BE SEEN, THE CORE DATA STRUCTURE THAT WE NEED TO IMPLEMENT THEREFORE IS THE CASE BASE.
utt_0028 utt 198.26 204.02 -X AS CASE BASE FOR TONIC, WE INTRODUCE A NEW KIND OF SYNOPSIS WHICH WE CALL
utt_0029 utt 204.05 213.43 -X QUERY EXECUTION PLAN SYNOPSIS OR QEP-S IN SHORT. THE QEP-S BASICALLY IS A PREFIX TREE
utt_0030 utt 213.49 228.19 -X OF LOGICAL JOIN ORDERS WHICH ALLOWS US TO SHARE PARTIAL JOIN ORDERS ACROSS MULTIPLE PLANS. FOR INSTANCE PLAN one IN THIS EXAMPLE JOINS R AND S WHILE PLAN two ADDITIONALLY JOINS U.
utt_0032 utt 228.73 236.70 -X IN THIS CONTEXT WE CONSIDER PLAN one AS A PREFIX OF PLAN two AS BOTH SHARE THE SAME JOIN OF R AND S.
utt_0033 utt 238.36 251.42 -X NOW THE MAIN TRICK IS THAT WE STORE A COST SUMMARY FOR DIFFERENT PHYSICAL JOIN OPERATORS AT EACH NODE WHICH TELLS US THE OPERATOR THAT IS VERY LIKELY TO BE THE MOST COST-EFFICIENT OPERATOR
utt_0035 utt 251.42 260.60 -X FOR THE NEXT JOIN ALONG THE PREFIX. FOR INSTANCE, HERE WE SEE THAT CT STORES JOIN OPERATOR COSTS
utt_0036 utt 260.60 266.84 -X FOR JOINING T AND S USING A NESTED LOOP JOIN OR A HASH JOIN RESPECTIVELY.
utt_0037 utt 267.99 276.03 -X THE SUM WITHIN CT INDICATES THAT WE CONSIDER THE OPERATOR COSTS OF ALL PREVIOUS PLANS THAT MATCH
utt_0038 utt 276.03 283.20 -X THE ABSTRACT PREFIX. ALTHOUGH THIS EXAMPLE ONLY CONSIDERS LINEAR JOIN PATHS FOR PLANTS one TO four,
utt_0039 utt 283.77 290.04 -X THE QEP-S SEAMLESSLY INTEGRATES BUSHY JOIN PLANS AS WELL AS YOU CAN SEE IN THE PAPER.
utt_0040 utt 292.76 300.38 -X AS FOR THE OPERATION MODE OF TONIC, WE USE THE NATIVE OPTIMIZER OF A DBMS TO GENERATE AN INITIAL
utt_0041 utt 300.38 314.36 -X QUERY EXECUTION PLAN FOR THE CURRENT QUERY OF OUR GIVEN WORKLOAD. FROM THE INITIAL QUERY EXECUTION PLAN, WE RETRIEVE THE LOGICAL JOIN ORDER THAT IS THEN MATCHED AGAINST OUR QEP-S TO IDENTIFY
utt_0043 utt 315.45 323.69 -X THE LONGEST PREFIX MATCH. AFTERWARD, WE OVERWRITE THE OPERATOR SELECTION OF THE INITIAL PLAN
utt_0044 utt 323.69 331.71 -X BY REUSING THE LEARNED OPERATORS FOR EACH JOIN ALONG THE PREFIX MATCH. THE REFINED PLAN IS THEN
utt_0045 utt 331.71 346.61 -X EXECUTED AND AFTER QUERY EXECUTION, WE COLLECT THE TRUE SIZES OF INTERMEDIATE RESULTS. WE USE THE ACTUAL CARDINALITIES TO DERIVE VERY PRECISE OPERATOR COSTS FOR DIFFERENT JOIN IMPLEMENTATIONS
utt_0047 utt 346.61 352.51 -X FOR THE CURRENT QUERY. NOTE THAT THESE COST PREDICTIONS CAN BE ASSUMED TO BE VERY ACCURATE
utt_0048 utt 352.57 356.77 -X AS WE USE ACTUAL CARDINALITIES INSTEAD OF ERROR-PRONE ESTIMATES.
utt_0049 utt 357.79 365.49 -X AND BASED ON THIS COST FEEDBACK WE UPDATE THE COST SUMMARY OF EACH QEP-S NODE FOR EXISTING
utt_0050 utt 365.49 373.57 -X PREFIXES AND ADD NEW BRANCHES INTO THE PREFIX TREE IF NECESSARY TO REFLECT THE NEW JOIN ORDER.
utt_0051 utt 375.45 380.58 -X NOW LET'S HAVE AN EXAMPLE TO BETTER UNDERSTAND THE OPERATION MODE.
utt_0052 utt 380.58 387.30 -X HERE WE ASSUME THAT WE ARE GIVEN AN EMPTY PREFIX TREE AND A FIRST QUERY THAT JOINS R,
utt_0053 utt 387.32 396.35 -X S, T, AND U. SINCE OUR QEP-S IS EMPTY AT THIS POINT ALL OPERATORS ARE SELECTED ACCORDING TO
utt_0054 utt 396.35 404.51 -X THE UNDERLYING OPTIMIZER AS THERE IS NO POSSIBLE PREFIX MATCH. HOWEVER, AFTER QUERY EXECUTION,
utt_0055 utt 404.51 411.68 -X WE USE THE ACTUAL CARDINALITIES TO DERIVE THE COST OF ALL JOIN OPERATOR ALTERNATIVES. ACCORDINGLY,
utt_0056 utt 411.68 420.93 -X WE ADD A NEW BRANCH TO THE QEP-S TO REFLECT THE PREFIX R-S-T-U AND STORE ALL RESPECTIVE OPERATOR
utt_0057 utt 420.93 427.65 -X COSTS AT EACH NODE. BASED ON THIS FEEDBACK WE SEE THAT A COMBINATION OF A NESTED LOOP JOIN,
utt_0058 utt 427.65 433.25 -X HASH JOIN, AND NESTED LOOP JOIN WOULD HAVE BEEN THE MOST COST-EFFICIENT FOR THE GIVEN QUERY.
utt_0059 utt 435.20 439.68 -X NOW AS A SECOND QUERY WE AGAIN JOIN R, S, T, AND U
utt_0060 utt 440.77 454.66 -X BUT WITH AN ADDITIONAL FILTER CONDITION ON TABLE S. NEVERTHELESS, TONIC IDENTIFIES A FULL PREFIX MATCH AND EXECUTES THE QUERY WITH THE OPERATOR SELECTION DETERMINED BY THE PREVIOUS QUERY.
utt_0062 utt 455.81 467.56 -X AFTER QUERY EXECUTION TONIC RECOGNIZES THAT IT ACTUALLY WOULD HAVE BEEN BETTER TO USE AN INDEX NESTED LOOP JOIN FOR JOINING T WITH ITS PREFIX DUE TO THE FILTER CONDITION.
utt_0064 utt 469.12 482.08 -X TO DECIDE NOW WHETHER TO RECOMMEND AN INDEX NESTED LOOP JOIN OR HASH JOIN FOR FUTURE QUERIES WE ADD THE OPERATOR COSTS OF THE CURRENT QUERY TO THE OPERATOR COSTS OF THE PAST QUERIES.
utt_0066 utt 482.40 495.84 -X THEREFORE BY USING THE OPERATOR WITH THE MINIMUM CUMULATIVE COST WE ARE VERY LIKELY TO SELECT THE MOST COST-EFFICIENT OPERATOR FOR FUTURE QUERIES. ANOTHER OPTION WOULD BE TO INTRODUCE A MORE
utt_0068 utt 495.84 502.37 -X AGGRESSIVE BRANCHING POLICY THAT INTRODUCES NEW PREFIXES FOR EACH INDIVIDUAL FILTER CONDITION.
utt_0069 utt 503.74 514.50 -X AND OF COURSE, THIS MORE AGGRESSIVE FILTER-AWARE BRANCHING POLICY THAT CAN BE FOUND IN THE PAPER HEAVILY REDUCES CONFLICTING OPERATOR DECISIONS AT EACH NODE
utt_0071 utt 516.67 523.81 -X NOW LET'S CONSIDER A THIRD QUERY WHICH JOINS V AND W TO THE EXISTING PREFIX R AND S.
utt_0072 utt 524.48 538.49 -X SINCE V AND W HAVE NOT YET BEEN CONSIDERED TONIC AGAIN USES THE NATIVE OPTIMIZER TO DECIDE ON THE OPERATOR SELECTION FOR THE JOIN V AND W. NEVERTHELESS, THE PARTIAL PREFIX MATCH FOR
utt_0074 utt 538.49 552.89 -X R-S NOW ALLOWS TONIC TO REUSE PAST EXPERIENCE AND RECOMMEND AN APPROPRIATE OPERATOR FOR THE FIRST JOIN. AFTER OVERVIEWING THE MAIN CONCEPT OF TONIC, WE WANT TO EVALUATE
utt_0076 utt 552.89 565.93 -X SOME OF TONIC'S CHARACTERISTICS NEXT. AS A PERFORMANCE OVERVIEW, WE SHOW HERE THE RESULTS OF THE JOIN ORDER BENCHMARK WHERE PRIMARY KEY AND FOREIGN KEY INDICES ARE PROVIDED.
utt_0078 utt 566.72 573.26 -X WE COMPARE THE STANDARD POSTGRES OPTIMIZER WITH AND WITHOUT TONIC AND DISTINGUISH TWO SCENARIOS.
utt_0079 utt 573.96 585.83 -X IN THE COLD START SETTING WHICH IS THE FIRST SCENARIO WE ONLY RUN THE BENCHMARK ONCE AND START WITH AN EMPTY QEP-S THAT IS UPDATED AFTER EACH QUERY EXECUTION. THIS ALLOWS
utt_0081 utt 585.83 599.24 -X US TO RATE TONIC'S CAPABILITIES OF TRANSFERRING STORED CASES TO NEW QUERIES. FOR THE HOT START SETTING ON THE OTHER HAND WE USE A WARM-UP PHASE AND A PRE-POPULATED QEP-S THAT ALREADY STORES
utt_0083 utt 599.24 606.86 -X ALL RELEVANT CASES AND THEREFORE COMES WITH A GUARANTEED PREFIX MATCH FOR ALL QUERIES.
utt_0084 utt 606.86 620.49 -X NOW IF WE FIRST FOCUS ON THE NATIVE POSTGRES PLANS WE SEE A HUGE DIFFERENCE BETWEEN THE COLD START AND THE HOT START SETTING WHICH INDICATES STRONG CACHING BEHAVIOR FOR THE NATIVE PLANTS.
utt_0086 utt 621.54 628.70 -X IN PARTICULAR, WE FOUND OUT THAT THE BENCHMARK EXECUTION TIME FOR THE NATIVE POSTGRES SYSTEM
utt_0087 utt 629.16 641.35 -X IS DICTATED MAINLY BY TWO OR THREE VERY LONG-RUNNING QUERIES. SO POSTGRES ACTUALLY SHOWS PROBLEMATIC TAIL LATENCIES. HOWEVER, COMBINING THE OPTIMIZER WITH TONIC REVEALS
utt_0089 utt 641.35 647.35 -X A SUBSTANTIAL SPEED UP IN BOTH SETTINGS. FIRST, WE SEE THAT TONIC IS ABLE TO TRANSFER
utt_0090 utt 647.43 651.79 -X MEANINGFUL OPERATOR DECISIONS TO UNKNOWN CASES IN THE COLD START SCENARIO
utt_0091 utt 651.91 659.31 -X AND SECOND TONIC IS CLOSE TO MATCH THE OPTIMAL OPERATOR SELECTION FOR THE HOT START SETTING.
utt_0092 utt 660.26 671.60 -X IN OUR PAPER, WE USE TONIC IN COMBINATION WITH SEVERAL OPTIMIZERS TO SHOW THAT TONIC IS NOT LIMITED TO THE POSTGRES OPTIMIZER. FOR INSTANCE, WE COMBINED TONIC WITH THE
utt_0094 utt 671.60 681.71 -X SIMPLICITY QUERY OPTIMIZER. SIMPLICITY IS A PESSIMISTIC JOIN ORDERING CONCEPT BASED ON A SIMPLE UPPER BOUND THAT HAS BEEN PUBLISHED twenty-one AT CIDR.
utt_0096 utt 685.13 698.03 -X IN PARTICULAR, SIMPLICITY SEEKS TO AVOID SINGLE LONG-RUNNING QUERIES BY FORCING one:N JOINS BEFORE POTENTIALLY EXPANDING AND THEREFORE MORE DANGEROUS N:M JOINS.
utt_0098 utt 698.54 703.76 -X AND THE N:M JOINS ARE ENUMERATED ACCORDING TO A CHEAP UPPER BOUND.
utt_0099 utt 705.61 711.77 -X FROM THE RESULTS, WE SEE THAT SIMPLICITY SUCCESSFULLY AVOIDS SINGLE LONG-RUNNING QUERIES
utt_0100 utt 711.98 716.46 -X AS IT EXECUTES MUCH FASTER IN THE COLD START SETTING.
utt_0101 utt 716.49 722.93 -X AND AGAIN COMBINING SIMPLICITY WITH TONIC SHOWS CLOSE TO OPTIMAL OPERATOR SELECTIONS
utt_0102 utt 723.02 731.18 -X AND THEREFORE IT BECOMES EVIDENT THAT TONIC WORKS IN TANDEM WITH ANY GENERIC QUERY OPTIMIZER.
utt_0103 utt 732.65 747.15 -X IN THIS LAST EXPERIMENT FOR THIS PRESENTATION, WE COMPARE TONIC TO BAO WHICH HAS BEEN PUBLISHED LAST YEAR ON SIGMOD. BAO IS A STATE-OF-THE-ART MACHINE LEARNING APPROACH THAT ALSO LEARNS FROM QUERY
utt_0105 utt 747.15 761.41 -X FEEDBACK -- MUCH LIKE TONIC. HOWEVER, INSTEAD OF USING A FINE-GRAINED OPERATOR SELECTION FOR INDIVIDUAL JOINS, BA LEARNS AND SELECTS SQL HINT SET COMBINATIONS --LIKE 'SET ENABLE_NEST_LOOP TO
utt_0107 utt 761.41 776.08 -X OFF' OR 'ON'-- TO GUIDE THE UNDERLYING OPTIMIZER TOWARD BETTER PLANNING DECISIONS. TO EVALUATE THE LEARNING CAPABILITIES OF BOTH APPROACHES WE RUN A PARTICULAR FRACTION OF TRAINING QUERIES AND FREEZE
utt_0109 utt 776.08 789.71 -X THE MODELS AFTERWARD. SO IN PARTICULAR THE QEP-S OF TONIC AND THE NEURAL NETWORK OF BAO. WITH THE SO FAR TRAINED MODELS, WE EXECUTE THE BENCHMARK END-TO-END AND MEASURE QUERY RESPONSE TIMES.
utt_0111 utt 791.21 804.69 -X AS CAN BE SEEN ON THE RIGHT-HAND SIDE TONIC SHOWS A VERY STABLE RATE OF IMPROVEMENT DUE TO ITS WHITE BOX LEARNING PARADIGM. TONIC ONLY REVISES OPERATOR SELECTIONS WHEN IT KNOWS THAT IT CAN DO BETTER
utt_0113 utt 804.69 812.82 -X THAN THE UNDERLYING OPTIMIZER DUE TO A GUARANTEED PREFIX MATCH. VICE VERSA TONIC RECOGNIZES WHEN
utt_0114 utt 812.82 827.63 -X IT'S IN COMPLETELY UNKNOWN TERRITORY AS THERE IS NO PREFIX MATCH. TONIC THEN SIMPLY FALLS BACK TO THE NATIVE OPTIMIZER FOR THE OPERATOR SELECTION. IN CONTRAST, ML APPROACHES CAN BE TRAINED ON A
utt_0116 utt 827.89 841.11 -X SMALL FRACTION OF QUERIES AND MAKE DECISIONS FOR COMPLETELY UNRELATED QUERIES. IN PARTICULAR, THE BLACK BOX NATURE OF NEURAL NETWORKS MAKES IT VERY HARD FOR US TO UNDERSTAND THE DECISION PROCESS.
utt_0118 utt 841.11 855.70 -X THIS BRINGS ME ALREADY TO THE END OF THIS PRESENTATION WHERE I HOPE I COULD GIVE YOU A NICE OVERVIEW OF OUR WORK WHERE WE PRESENT TONIC FOR NEAR-OPTIMAL OPERATOR SELECTIONS. TONIC
utt_0120 utt 855.70 868.18 -X CAN TURBOCHARGE GENERIC QUERY OPTIMIZERS WHILE FOLLOWING A WHITE BOX LEARNING PARADIGM. AND SINCE TONIC DIRECTLY LEARNS FROM QUERY FEEDBACK THERE IS NO NEED FOR ERROR-PRONE CARDINALITY ESTIMATES
utt_0122 utt 868.21 874.74 -2.8264 AND FURTHER AS CAN BE SEEN IN THE PAPER, TONIC IS PARTICULARLY FAST IN ADAPTING TO WORKLOAD CHANGES.
