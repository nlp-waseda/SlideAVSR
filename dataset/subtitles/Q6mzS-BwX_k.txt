utt_0000 utt 0.38 7.54 -X HI EVERYONE, MY NAME IS DA YAN AND I AM AN ASSISTANT PROFESSOR FROM THE COMPUTER SCIENCE DEPARTMENT OF THE UNIVERSITY OF ALABAMA AT BIRMINGHAM.
utt_0002 utt 7.95 11.68 -X I AM HERE TO PRESENT OUR ICDE two thousand and twenty SHORT PAPER
utt_0003 utt 11.79 17.68 -X TITLED PREFIXFPM: A PARALLEL FRAMEWORK FOR GENERAL-PURPOSE FREQUENT PATTERN MINING
utt_0004 utt 18.28 24.21 -X FIRST, LET ME INTRODUCE OUR TARGET PROBLEM, THAT IS, FREQUENT PATTERN MINING.
utt_0005 utt 24.21 27.66 -X WE WILL ILLUSTRATE THE CONCEPTS USING ITEMSETS AS THE PATTERNS.
utt_0006 utt 28.37 34.35 -X IN THIS SLIDE, WE HAVE A DATABASE OF six TRANSACTIONS INDICATING THE ITEMS THAT PEOPLE BUY FROM A SUPERMARKET.
utt_0007 utt 34.86 39.12 -X FROM THIS DATABASE, WE WOULD LIKE TO MINE PATTERNS IN THE FORM OF ITEMSETS,
utt_0008 utt 39.12 43.31 -X WHERE AN ITEMSET WITH three ITEMS IS SHOWN AT THE BOTTOM.
utt_0009 utt 43.31 46.32 -X FOR A PATTERN, WE HAVE THE CONCEPT OF PATTERN LENGTH.
utt_0010 utt 46.86 48.53 -X IN OUR ITEMSET PATTERN,
utt_0011 utt 48.53 53.55 -X THE SIZE IS three SINCE WE HAVE three ITEMS IN THE SET.
utt_0012 utt 53.55 56.08 -X IF WE CHECK THE ITEMSET AGAINST THE DATABASE,
utt_0013 utt 56.49 60.11 -X WE CAN SEE THAT TRANSACTIONS four AND six COVER OUR ITEMSET,
utt_0014 utt 60.11 63.78 -X AND THEREFORE, WE SAY THAT THE SUPPORT COUNT OF OUR PATTERN IS two
utt_0015 utt 64.37 70.39 -X WE CAN ALSO DEFINE SUPPORT AS THE FRACTION OF TRANSACTIONS IN THE DATABASE THAT COVER OUR PATTERN,
utt_0016 utt 70.61 72.75 -X WHICH IS ONE-THIRD IN OUR CASE.
utt_0017 utt 74.38 77.71 -X HERE IS A RECAP OF THE CONCEPTS IN FREQUENT PATTERN MINING.
utt_0018 utt 77.71 85.75 -X WE HAVE A DATABASE OF TRANSACTIONS, AND WE WANT TO FIND THOSE PATTERNS THAT ARE COVERED BY A SIGNIFICANT NUMBER OF TRANSACTIONS IN OUR DATABASE.
utt_0020 utt 85.75 89.56 -X WE REMARK THAT THE PATTERN TYPE IS NOT LIMITED TO ITEMSET.
utt_0021 utt 89.68 95.03 -X DEPENDING ON THE DATABASE TYPE, A PATTERN CAN ALSO BE A SUBSEQUENCE, A SUBGRAPH OR EVEN A SUBTREE.
utt_0022 utt 95.41 101.36 -X FOR EXAMPLE, IN A DATABASE OF CHEMICAL COMPOUNDS, IT WOULD BE INTERESTING TO FIND FREQUENT SUBGRAPH STRUCTURES
utt_0023 utt 101.90 104.82 -X THAT OFTEN HINTS USEFUL FUNCTIONALITIES.
utt_0024 utt 105.42 110.52 -X AS ANOTHER EXAMPLE, WE CAN ALSO MINE SUBTREE PATTERNS FROM AN XML FILE
utt_0025 utt 110.58 116.88 -X SUCH AS THAT OF DBLP, TO CAPTURE PATTERNS LIKE FREQUENT COAUTHORSHIPS IN A PARTICULAR JOURNAL.
utt_0026 utt 116.88 130.29 -X * IT IS ALSO COMMON TO ADD CONSTRAINTS TO THE DESIRED PATTERNS, SUCH AS THAT TWO ELEMENTS IN A SEQUENTIAL PATTERN CANNOT BE MORE THAN three ELEMENTS AWAY IN A SEQUENCE TRANSACTION.
utt_0028 utt 130.29 139.86 -X IN THIS SLIDE, WE SHOW A TREE-STRUCTURED TRANSACTION, AND IF WE CONSIDER EMBEDDED PATTERN WHICH ONLY REQUIRES THE PRESERVATION OF ANCESTOR-DESCENDANT RELATIONSHIP BETWEEN NODES,
utt_0030 utt 140.34 149.21 -X THEN THE PATTERN BBD IS COVERED EVEN THOUGH IT IS NOT AN INDUCED SUBGRAPH OF THE TREE TRANSACTION.
utt_0031 utt 149.21 149.75 -X IN FACT,
utt_0032 utt 149.84 157.94 -X FREQUENT PATTERN MINING IS NP-HARD, AND IT IS IMPORTANT TO UTILIZE ALL THE CPU CORES IN A MULTI-CORE MACHINE FOR EFFECTIVE PATTERN MINING.
utt_0033 utt 158.45 166.39 -X THEREFORE, WE AIM TO DESIGN A PARALLEL FRAMEWORK THAT IS ABLE TO KEEP ALL CPU CORES BUSY IN MINING FREQUENT PATTERNS.
utt_0034 utt 166.39 172.89 -X AN IMPORTANT GOAL IS TO MAKE OUR FRAMEWORK'S PROGRAMMING INTERFACE GENERAL ENOUGH FOR MINING ALL KINDS OF PATTERNS.
utt_0035 utt 173.43 179.67 -X WE REMARK THAT THE PATTERN OF ITEMSET IS SPECIAL BECAUSE THERE IS NO ORDER OVER THE ITEMS IN A SET,
utt_0036 utt 180.59 187.48 -X SO WE CAN USE ALGORITHMS THAT DEFINE ITS OWN ORDER FOR EFFECTIVE MINING, SUCH AS THE FP-GROWTH ALGORITHM.
utt_0037 utt 187.48 193.97 -X HOWEVER, WE DO NOT TARGET THIS PROBLEM AS IT HAS BEEN WELL ADDRESSED BY GOOGLE'S PARALLEL FP-GROWTH ALGORITHM,
utt_0038 utt 193.97 195.41 -X WHICH IS SHOWN AT THE TOP.
utt_0039 utt 195.89 202.46 -X WE CONSIDER THOSE PATTERNS WHERE IT MATTERS HOW THE ELEMENTS ARE ORDERED OR CONNECTED.
utt_0040 utt 202.80 206.68 -X OUR FRAMEWORK IS DESIGNED BASED ON THE IDEA OF PREFIX PROJECTION,
utt_0041 utt 206.71 209.75 -X THE IDEA OF WHICH WILL BE REVIEWED SHORTLY.
utt_0042 utt 210.45 212.38 -X OUR FRAMEWORK IS CALLED PREFIXFPM
utt_0043 utt 212.79 218.49 -X AS WE USE PREFIX PROJECTION AND TACKLES GENERAL FREQUENT PATTERN MINING, OR FPM IN SHORT.
utt_0044 utt 219.22 227.38 -X AN IMPORTANT FEATURE OF PREFIXFPM IS THAT, WE CONSIDER ALGORITHMS THAT CHECK PATTERNS IN THE DEPTH-FIRST ORDER OF PATTERN GROWTH.
utt_0045 utt 227.38 235.77 -X LET US NOW ILLUSTRATE THE IDEA OF PREFIX PROJECTION BY CONSIDERING THE PROBLEM OF MINING FREQUENT SUBSEQUENCE PATTERNS FROM A SEQUENCE DATABASE.
utt_0046 utt 236.18 243.48 -X HERE, WE CAN SEE THAT DATABASE D HAS four SEQUENCES. IF WE CONSIDER PATTERN A, THEN Sfour IS FILTERED AS IT HAS NO A,
utt_0047 utt 243.76 251.22 -X AND THE UNDERSCORED POSITIONS ARE THOSE THAT MATCH A. WE CALL SUCH A DATABASE AS A PROJECTED DATABASE PROJECTED BY PATTERN A.
utt_0048 utt 251.99 255.06 -X NOW IF WE GROW PATTERN A WITH ONE MORE ELEMENT B,
utt_0049 utt 255.22 259.55 -X WE ONLY NEED TO CONTINUE MATCHING FROM THE PROJECTED DATABASE OF A.
utt_0050 utt 259.77 264.39 -X WE WILL CONTINUE MATCHING B STARTING FROM THE UNDERSCORED POSITIONS
utt_0051 utt 264.79 268.03 -X THIS WILL GIVE US THE PROJECTED DATABASE OF AB.
utt_0052 utt 269.17 275.07 -X WE CAN FURTHER GROW THE PATTERN BY C, AND CHECK AGAINST THE PROJECTED DATABASE OF AB TO FIND
utt_0053 utt 275.83 278.65 -X THOSE SEQUENCE TRANSACTIONS THAT CONTAIN PATTERN ABC.
utt_0054 utt 280.92 285.27 -X PREFIXSPAN ACTUALLY CHECKS THE PATTERNS IN DEPTH-FIRST PATTERN-GROWING ORDER.
utt_0055 utt 285.65 290.49 -X LET US CONSIDER A SEQUENCE DATABASE WHERE THERE ARE ONLY three ELEMENT TYPES, A, B AND C.
utt_0056 utt 292.34 300.70 -X WE WILL FIRST GROW AN INITIAL EMPTY PATTERN BY A TO OBTAIN A'S PROJECTED DATABASE.
utt_0057 utt 300.70 305.02 -X IF IT CONTAINS SUFFICIENT TRANSACTIONS, WE CONSIDER A AS FREQUENT AND OUTPUT IT.
utt_0058 utt 305.85 310.68 -X WE THEN GROW PATTERN A INTO AA, CREATE ITS PROJECTED DATABASE FROM THAT OF A.
utt_0059 utt 311.35 322.49 -X ASSUME THAT THE PROJECTED DATABASE DOES NOT HAVE SUFFICIENT TRANSACTIONS, SO AA IS INFREQUENT. THEN, AA IS PRUNED AND WE DO NOT NEED TO CONSIDER TO GROW AA FURTHER.
utt_0061 utt 323.61 330.36 -X AFTER BACKTRACKING TO PATTERN A, WE WILL CONSIDER THE NEXT CHILD PATTERN AB, AND ASSUME THAT IT IS FREQUENT.
utt_0062 utt 330.36 333.85 -X * THEN WE WILL CONTINUE TO CHECK ITS CHILD-PATTERNS ABA,
utt_0063 utt 334.23 344.48 -X ABB AND ABC WE WILL CONTINUE TO CHECK ALL THE PATTERNS IN DEPTH-FIRST ORDER OF THE PATTERN-GROWTH TREE, UNTIL ALL FREQUENT PATTERNS ARE FOUND.
utt_0065 utt 344.92 347.55 -X THIS ALGORITHM HAS SEVERAL DESIRABLE FEATURES.
utt_0066 utt 348.66 356.99 -X FIRSTLY, WE ONLY CHECK A CHILD-PATTERN OVER ITS PARENT-PATTERN'S PROJECTED DATABASE, WHICH GETS SMALLER AS THE PARENT-PATTERN GROWS IN SIZE.
utt_0067 utt 357.53 365.95 -X SECONDLY, WE CAN PRUNE THE WHOLE SUBTREE IN OUR PATTERN SEARCH SPACE ONCE A PATTERN IS FOUND TO BE INFREQUENT.
utt_0068 utt 365.95 370.43 -X THIRDLY, WE WILL REMEMBER HOW A PARENT-PATTERN IS MATCHED TO EACH TRANSACTION,
utt_0069 utt 370.43 374.59 -X SO THAT A CHILD-PATTERN CAN CONTINUE ITS MATCHING RATHER THAN STARTING FROM SCRATCH.
utt_0070 utt 375.67 383.81 -X FINALLY, ALL CHILD-SUBTREES CAN BE CHECKED INDEPENDENTLY AND ARE THEREFORE AMENABLE TO PARALLEL COMPUTING.
utt_0071 utt 385.72 390.78 -X WE REMARK THAT THIS PREFIX-PROJECTION IDEA IS NOT LIMITED TO MINING SEQUENTIAL PATTERNS.
utt_0072 utt 390.97 395.26 -X FOR EXAMPLE, WE CAN FIND SUBGRAPH PATTERNS FROM A GRAPH DATABASE IN A SIMILAR MANNER.
utt_0073 utt 395.48 400.41 -X FOR THIS PURPOSE, WE NEED TO ENCODE EACH GRAPH PATTERN INTO A SEQUENCE REPRESENTATION.
utt_0074 utt 400.63 406.56 -X THIS ALLOWS US TO RUN A PREFIXSPAN-STYLE ALGORITHM ON THE ENCODED SEQUENCE PATTERN SPACE.
utt_0075 utt 407.42 413.60 -X THIS WILL HOWEVER GIVE RISE TO DUPLICATE PATTERNS SINCE DIFFERENT SEQUENCES CAN CORRESPOND TO THE SAME SUBGRAPH.
utt_0076 utt 414.49 420.99 -X TAKING TREE PATTERNS AS AN EXAMPLE, WHERE WE DO NOT DIFFERENTIATE THE ORDER OF CHILDREN NODES.
utt_0077 utt 420.99 425.37 -X HERE WE CAN SIMPLY ENCODE A TREE PATTERN USING DEPTH-FIRST NODE TRAVERSAL,
utt_0078 utt 425.37 429.44 -X EXCEPT THAT WE NEED TO ADD A DOLLAR SIGN EACH TIME WE BACKTRACK.
utt_0079 utt 430.62 432.90 -X FOR EXAMPLE, FOR THE FIRST TREE,
utt_0080 utt 437.63 439.42 -X WE HAVE BAB$D$$B$C$.
utt_0081 utt 440.70 449.06 -X WE CAN SEE THAT THE OTHER TWO TREES ARE THE SAME PATTERN BUT WITH DIFFERENT CHILDREN ORDER, BUT THEIR ENCODINGS ARE DIFFERENT.
utt_0083 utt 450.30 456.64 -X THEREFORE, A CANONICAL ENCODING IS UNIQUELY DEFINED FOR EACH PATTERN AS THE SMALLEST SEQUENCE ENCODING
utt_0084 utt 456.80 460.70 -X AMONG THAT PATTERN'S ALL POSSIBLE ENCODINGS.
utt_0085 utt 460.70 465.22 -X DURING THE ACTUAL MINING, WE ONLY CONSIDER AND GROW A PATTERN IF ITS ENCODING IS CANONICAL.
utt_0086 utt 468.19 474.85 -X AS THE PATTERN SEARCH TREE SHOWS, Gzero'S ENCODING IS CANONICAL BUT Gone'S IS NOT.
utt_0087 utt 474.85 483.46 -X Gone AND Gzero ARE ACTUALLY THE SAME SUBGRAPH PATTERN, AND THEREFORE WE PRUNE Gone TO AVOID DUPLICATED PATTERN CHECKING.
utt_0088 utt 483.46 486.66 -X PATTERN GROWTH IS USUALLY BY AN ADDITIONAL ELEMENT EACH TIME,
utt_0089 utt 487.26 492.42 -X AND SUBGRAPH PATTERNS ALSO DO NOT NEED TO CONSIDER ALL GROWING POSSIBILITIES.
utt_0090 utt 492.42 498.27 -X FOR EXAMPLE, WE DO NOT NEED TO CONSIDER GROWING FROM NODE two IN THE SLIDE SINCE X IS NOT ON THE RIGHTMOST PATH.
utt_0091 utt 498.53 507.84 -X THIS IS BECAUSE OUR ENCODING IS IN DEPTH-FIRST ORDER AND AN EARLIER ENCODING IN DFS ORDER SHOULD HAVE CONSIDERED THAT BRANCH.
utt_0092 utt 507.84 511.55 -X NOW LET'S BRIEFLY OVERVIEW THE RELATED WORK.
utt_0093 utt 511.55 518.50 -X THERE ARE A LOT OF EARLIER WORKS THAT ADAPT THE APRIORI ALGORITHM ON MAPREDUCE TO GROW PATTERNS IN A BREADTH-FIRST ORDER,
utt_0094 utt 518.69 523.33 -X WHERE PATTERNS OF SIZE I IS CHECKED ONLY IF ALL SMALLER PATTERNS HAVE BEEN CHECKED.
utt_0095 utt 523.33 531.49 -X FOR EXAMPLE, SIZEminus one PATTERNS WILL FIRST BE MINED. THESE PATTERNS ARE THEN SAVED TO HADOOP DISTRIBUTED FILE SYSTEM, OR HDFS IN SHORT.
utt_0096 utt 532.06 538.15 -X THE NEXT MAPREDUCE JOB WILL THEN LOAD THEM BACK, MINE SIZEminus two PATTERNS GROWN FROM THEM, AND SAVE TO HDFS.
utt_0097 utt 538.15 542.11 -X THEY ARE THEN LOADED BACK TO MINE PATTERNS OF SIZE three.
utt_0098 utt 543.20 552.48 -X A PROBLEM WITH SUCH A MAPREDUCE SOLUTION IS THAT TRANSACTIONS AND PATTERNS ARE REPEATEDLY SAVED TO HDFS AND THEN LOADED BACK, WHICH INCURS A LOT OF IO OVERHEAD.
utt_0100 utt 553.15 561.32 -X SECONDLY, THE PATTERNS NEED TO BE CHECKED AGAINST THE ENTIRE TRANSACTION DATABASE RATHER THAN A SMALL PROJECTED DATABASE.
utt_0101 utt 561.32 567.62 -X A SATISFACTORY SOLUTION THAT USES THE DEPTH-FIRST FP-GROWTH ALGORITHM IS PROPOSED BY GOOGLE RESEARCHERS,
utt_0102 utt 567.65 575.01 -X WHICH MAKE THE FP-GROWTH ALGORITHM RUN IN PARALLEL WITH A MAPREDUCE JOB.
utt_0103 utt 575.01 578.28 -X THE PREVIOUS WORKS ARE ON ITEMSET PATTERNS.
utt_0104 utt 579.04 587.36 -X REGARDING SUBGRAPH PATTERNS, A DEPTH-FIRST SOLUTION IS PROPOSED IN ICDE two thousand and fourteen, USING TWO ROUNDS OF MAPREDUCE.
utt_0105 utt 587.36 593.64 -X IN THE FIRST JOB, TRANSACTIONS ARE PARTITIONED AMONG MACHINES, AND EACH MACHINE ONLY MINES ITS LOCAL FREQUENT PATTERNS IN DEPTH-FIRST ORDER.
utt_0106 utt 594.11 598.44 -X THESE PATTERNS ARE THEN UNIONED AND GIVEN TO THE SECOND JOB FOR REFINEMENT.
utt_0107 utt 598.44 607.40 -X THIS IS CORRECT BECAUSE IF A PATTERN IS NOT FREQUENT ON ALL LOCAL TRANSACTION DATABASES, IT CANNOT BE FREQUENT GLOBALLY FOR THE WHOLE DATABASE.
utt_0109 utt 607.40 614.31 -X THE WORK ACTUALLY ALSO INCORPORATES SOME LOCAL PATTERNS THAT ARE JUST BELOW BUT ONLY SLIGHTLY BELOW THE SUPPORT THRESHOLD
utt_0110 utt 614.40 620.55 -X TO FURTHER IMPROVE THE REFINEMENT EFFECTIVENESS.
utt_0111 utt 620.55 629.13 -X MORE RECENTLY, ARABESQUE PROPOSES A VERY USER-FRIENDLY PROGRAMMING INTERFACE FOR GRAPH MINING, CALLED EMBEDDING-CENTRIC PROGRAMMING
utt_0113 utt 629.13 636.61 -X HERE, AN EMBEDDING IS A MATERIALIZED SUBGRAPH, AND THESE SUBGRAPHS ARE STILL GROWN IN A BREADTH-FIRST MANNER FOR CHECKING.
utt_0114 utt 636.61 641.51 -X ARABESQUE IS A DISTRIBUTED SYSTEM AND SUBGRAPH MATERIALIZATION MAKES IT NETWORK IO-BOUND.
utt_0115 utt 642.66 650.89 -X A FOLLOW-UP WORK CALLED RSTREAM, IS A SINGLE-MACHINE OUT-OF-CORE SYSTEM THAT FOLLOWS ARABESQUE'S API, BUT IS FOUND TO BE MORE EFFICIENT.
utt_0116 utt 651.43 654.47 -X HOWEVER, RSTREAM IS DISK IO-BOUND.
utt_0117 utt 655.97 662.98 -X WE REMARK THAT ARABESQUE TRIES TO COMBINE FREQUENT SUBGRAPH PATTERN MINING WITH PROBLEMS LIKE CLIQUE MINING, BUT THEY ARE DIFFERENT PROBLEMS.
utt_0118 utt 663.33 668.17 -X FOR EXAMPLE, CLIQUES ARE PREDEFINED PATTERNS AND THE PROBLEM FINDS
utt_0119 utt 668.45 673.54 -X MATCHED INSTANCES IN A DATA GRAPH, BUT OUR PROBLEM DOES NOT PREDEFINE SUBGRAPH PATTERNS,
utt_0120 utt 673.54 679.46 -X BUT CHECKS INSTANCES IN OUR DATABASE TO FIND THESE FREQUENT PATTERNS.
utt_0121 utt 679.46 685.70 -X IN FACT, ARABESQUE'S API FORCES DENSE SUBGRAPH MINING PROBLEMS TO CONDUCT UNNECESSARY SUBGRAPH ISOMORPHISM CHECK,
utt_0122 utt 685.76 692.65 -X AS WELL AS SUBGRAPH MATERIALIZATION WHICH CAN OTHERWISE BE HANDLED BY SIMPLE NODE BACKTRACKING.
utt_0123 utt 692.65 699.59 -X OUR G-THINKER SYSTEM SATISFACTORILY ADDRESSES THESE WEAKNESSES AND PLEASE CHECK OUT OUR PRESENTATION ON G-THINKER!
utt_0124 utt 700.80 702.28 -X WE ADOPT A
utt_0125 utt 702.50 707.27 -X TASK-CENTRIC COMPUTATION MODEL, WHERE EACH PATTERN IS ASSOCIATED WITH A TASK.
utt_0126 utt 707.81 710.86 -X THE TASK WILL CHECK IF THAT PATTERN IS FREQUENT,
utt_0127 utt 711.24 717.96 -X AND IF SO, IT WILL GROW THE PATTERN BY ONE MORE ELEMENT TO GENERATE CHILD-PATTERNS FOR FURTHER CHECKING.
utt_0128 utt 717.96 726.73 -X IF THE PROJECTED DATABASE IS BIG, CHILD-PATTERNS ARE WRAPPED INTO INDEPENDENT TASKS WHICH ARE THEN ADDED TO A TASK QUEUE TO BE FETCHED BY OTHER THREADS FOR MINING.
utt_0130 utt 727.49 737.32 -X OTHERWISE, THE TASK IS EFFICIENT TO PROCESS BY THE CURRENT THREAD ITSELF SO THE THREAD WILL DIRECTLY PROCESS IT IN DEPTH-FIRST PATTERN GROWTH ORDER.
utt_0132 utt 737.32 744.46 -X THIS FRAMEWORK FOLLOWS OUR T-THINKER PROGRAMMING PARADIGM AND WE ENCOURAGE YOU TO CHECK IT OUT!
utt_0133 utt 744.46 748.27 -X THIS SLIDE SHOWS HOW A THREAD PROCESSES A TASK, WHERE LINE two
utt_0134 utt 748.52 753.42 -X FIRST CHECKS IF WE NEED TO SKIP THE CURRENT PATTERN, SAY, ITS ENCODING IS NOT CANONICAL.
utt_0135 utt 754.25 758.57 -X THEN LINE four WILL GENERATE CHILD PATTERNS AND THEIR PROJECTED DATABASES.
utt_0136 utt 759.33 768.49 -X EACH CHILD-PATTERN IS THEN PROCESSED IN THE WHILE LOOP WHERE LINE seven CHECKS IF WE SHOULD WRAP CHILD-PATTERNS INTO TASKS FOR CONCURRENT PROCESSING.
utt_0138 utt 768.97 778.06 -X OTHERWISE, THE CURRENT THREAD WILL CALL THE SAME FUNCTION IN LINE thirteen ON THE CHILD-PATTERN TO CHECK AND GROW IT RECURSIVELY.
utt_0139 utt 778.06 784.62 -X WE MAKE THE TASK QUEUE A STACK SO THAT TASKS ARE FETCHED IN DEPTH-FIRST PRIORITY. THIS STRATEGY
utt_0140 utt 784.62 793.23 -X PRIORITIZES OLD TASKS TO MINIMIZE MEMORY FOOTPRINT OCCUPIED BY THE PROJECTED DATABASES THAT ARE BEING MINED UPON.
utt_0141 utt 793.86 796.36 -X OUR PROGRAMMING INTERFACE IS SHOWN HERE,
utt_0142 utt 796.36 801.96 -X WHERE WE HAVE COVERED THOSE USER-DEFINED FUNCTIONS OF THE TASK BASE CLASS IN OUR PREVIOUS SLIDE.
utt_0143 utt 802.50 809.10 -X THERE IS ALSO A WORKER BASE CLASS WHICH CREATES THE INITIAL SIZEminus one PATTERN TASKS
utt_0144 utt 809.67 814.80 -X AND PUTS THEM INTO THE TASK QUEUE FOR CONCURRENT PROCESSING,
utt_0145 utt 814.80 821.68 -X THIS IS ACTUALLY CONDUCTED BY THE SETROOT(.) FUNCTION WHICH IS ALSO USER-DEFINED.
utt_0146 utt 821.68 825.58 -X HERE, WE ILLUSTRATE HOW OUR PARALLEL FRAMEWORK DIVIDES THE PATTERN SEARCH SPACE.
utt_0147 utt 825.67 834.83 -X FOR EXAMPLE, THREAD one COULD BE PROCESSING PATTERN AB. THE NEXT PATTERN IN DEPTH-FIRST ORDER, WHICH IS AC, IS FETCHED AND PROCESSED BY THREAD two.
utt_0148 utt 834.83 838.99 -X THREAD three AND THREAD four WILL THEN PROCESS THE NEXT two PATTERNS IN DEPTH-FIRST ORDER.
utt_0149 utt 839.56 848.75 -X NOTE THAT THESE TASKS MAY ADD MORE CHILD-PATTERN TASKS INTO THE CURRENT TASK QUEUE, SO THAT IDLE THREADS CAN THEN FETCH THEM FOR PROCESSING.
utt_0150 utt 848.75 853.23 -X WE ALSO ALLOW A PATTERN TO BE CHECKED AGAINST A BIG PROJECTED DATABASE IN PARALLEL,
utt_0151 utt 853.23 859.41 -X WHICH IS HELPFUL INITIALLY WHEN THERE ARE NOT MANY TASKS TO KEEP ALL THE CPU CORES BUSY.
utt_0152 utt 859.69 867.15 -X WE HAVE OPEN-SOURCED OUR CODE ON GITHUB WITH DETAILED DOCUMENTATION, AND THERE IS ALSO A VIDEO DEMO FOR YOU TO CHECK OUT!
utt_0153 utt 868.17 872.78 -X WE IMPLEMENTED THREE ALGORITHMS ON TOP OF OUR PREFIXFPM FRAMEWORK,
utt_0154 utt 872.78 877.33 -X WHICH ARE PARALLEL VERSIONS OF PREFIXSPAN FOR SEQUENCE PATTERNS,
utt_0155 utt 877.33 881.20 -X GSPAN FOR SUBGRAPH PATTERNS, AND SLEUTH FOR EMBEDDED TREE PATTERNS.
utt_0156 utt 881.90 888.53 -X OUR EXPERIMENTS SHOW IDEAL SPEEDUP WITH THE NUMBER OF CPU CORES IN OUR SERVER WHICH CONTAINS thirty-two CPU CORES.
utt_0157 utt 889.42 893.90 -5.4709 THANKS FOR YOUR ATTENTION! AND HERE ARE MY CONTACT INFORMATION AND SOME USEFUL LINKS.
