utt_0000 utt 0.49 3.95 -X HI. MY NAME IS JIALIN AND I'LL BE PRESENTING OUR WORK ON TSUNAMI,
utt_0001 utt 3.95 18.58 -X A LEARNED MULTI-DIMENSIONAL INDEX FOR CORRELATED DATA AND SKEWED WORKLOADS. SO THE MOTIVATION BEHIND TSUNAMI IS THAT WE WANT TO IMPROVE THE PERFORMANCE OF SCANNING AND FILTERING, WHICH IS A KEY STEP IN PROCESSING ANALYTICS QUERIES. AND TO EXPLAIN WHAT I MEAN BY SCANNING AND FILTERING,
utt_0004 utt 18.58 22.38 -X LET'S IMAGINE THAT IN YOUR DATA WAREHOUSE YOU HAVE THIS SIMPLIFIED TABLE, WITH TWO COLUMNS,
utt_0005 utt 22.38 31.35 -X AGE AND SALARY. NOW FOR ILLUSTRATIVE PURPOSES, WE'RE GOING TO VISUALIZE THE ROWS OF THIS TABLE AS POINTS IN MULTI-DIMENSIONAL SPACE. SO HERE THE X-AXIS REPRESENTS AGE,
utt_0007 utt 31.35 35.79 -X THE Y-AXIS REPRESENTS SALARY, AND EVERY POINT REPRESENTS A RECORD IN THE ORIGINAL TABLE.
utt_0008 utt 36.17 46.90 -X SO NOW LET'S SAY A USER WANTS TO RUN THIS QUERY: COMPUTE SOME AGGREGATION OVER ALL POINTS WHERE THE AGE IS BETWEEN forty AND fifty AND THE SALARY IS BETWEEN eighty AND one hundredK. SO VISUALLY, THE QUERY'S
utt_0010 utt 46.90 60.31 -X FILTER CAN BE REPRESENTED AS THIS GREEN RECTANGLE BECAUSE THE QUERY NEEDS TO FIND ALL POINTS INSIDE THE RECTANGLE. AND THE MOST STRAIGHTFORWARD WAY TO FIND THOSE POINTS IS TO DO A FULL TABLE SCAN OVER ALL THE POINTS, BUT THIS RESULTS IN A LOT OF EXTRA SCANNING OVER POINTS THAT ARE NOT RELEVANT,
utt_0013 utt 60.31 69.70 -X WHICH I'VE SHADED IN RED. AND OBVIOUSLY ALL THIS EXTRA SCANNING INCREASES QUERY TIME AND HURTS PERFORMANCE, SO ONE VERY COMMON WAY FOR SYSTEMS TO REDUCE THE AMOUNT OF SCANNING IS TO SORT THE DATA
utt_0015 utt 69.70 84.66 -X BY A CERTAIN DIMENSION. SO FOR EXAMPLE IF WE SORT ALL THE POINTS BY AGE, WE CAN AVOID SCANNING ANY POINT WHOSE AGE IS NOT BETWEEN forty AND fifty. BUT THE DOWNSIDE IS THAT THIS DOESN'T HELP US FILTER OVER THE SALARY DIMENSION, SO WE STILL END UP SCANNING A LOT OF EXTRA DATA, WHICH I'VE SHADED IN RED.
utt_0018 utt 84.66 89.20 -X AND OF COURSE IF WE INSTEAD SORT BY SALARY, WE END UP WITH ESSENTIALLY THE SAME PROBLEM.
utt_0019 utt 89.46 102.98 -X SO INSTEAD OF SORTING BY A SINGLE DIMENSION, WHAT WE CAN DO INSTEAD IS SORT BASED ON A MULTI-DIMENSIONAL GRID. SO FOR EXAMPLE, ON THE RIGHT WE HAVE A GRID WITH SIX VERTICAL PARTITIONS OVER AGE AND FIVE HORIZONTAL PARTITIONS OVER SALARY, WHICH WHEN COMBINED GIVES US A GRID
utt_0022 utt 102.98 108.24 -X WITH thirty UNIFORMLY SIZED CELLS. NOW ALL POINTS FALLING IN THE SAME CELL ARE STORED CONTIGUOUSLY,
utt_0023 utt 108.30 118.10 -X SO NOW WE ONLY SCAN THE POINTS IN THE CELLS THAT OVERLAP WITH THE GREEN QUERY RECTANGLE. SO ESSENTIALLY THIS GRID LAYOUT GIVES US THE ABILITY TO FILTER BY BOTH DIMENSIONS SIMULTANEOUSLY.
utt_0025 utt 118.54 129.49 -X NOW, ONE MAJOR CHALLENGE WITH GRID LAYOUTS IS HOW TO CONFIGURE THEM, MEANING WHICH DIMENSIONS TO INCLUDE IN THE GRID AND ALSO HOW MANY PARTITIONS TO CREATE IN EACH DIMENSION. SO IN OUR PRIOR WORK
utt_0027 utt 129.49 138.93 -X PUBLISHED IN LAST YEAR'S SIGMOD, WE INTRODUCED A LEARNED MULTI-DIMENSIONAL INDEX CALLED FLOOD THAT IS ABLE TO AUTOMATICALLY ADAPT THE LAYOUT OF THE GRID FOR A PARTICULAR QUERY WORKLOAD.
utt_0029 utt 139.34 153.08 -X SO FOR EXAMPLE LET'S SAY THERE'S TWO USERS, EACH WITH THEIR OWN WORKLOAD, LABELED A AND B, AND HERE I'VE SHOWN TWO QUERIES SAMPLED FROM EACH WORKLOAD. NOW WORKLOAD A'S QUERIES ARE MUCH MORE SELECTIVE OVER THE SALARY DIMENSION THAN OVER THE AGE DIMENSION AND SO FLOOD WOULD AUTOMATICALLY
utt_0032 utt 153.08 157.37 -X CREATE A GRID THAT HAS MANY MORE PARTITIONS OVER SALARY THAN AGE, WHICH MINIMIZES SCANNING.
utt_0033 utt 157.78 171.80 -X NOW ON THE OTHER HAND, FOR WORKLOAD B FLOOD WOULD AUTOMATICALLY CREATE AN ENTIRELY DIFFERENT GRID SPECIALIZED FOR JUST THE QUERIES IN WORKLOAD B. SO THIS IS THE REASON WE CALL FLOOD A LEARNED MULTI-DIMENSIONAL INDEX, BECAUSE IT'S ABLE TO LEARN THE BEST GRID LAYOUT FOR A SPECIFIC QUERY
utt_0036 utt 171.80 180.05 -X WORKLOAD AND DATA SET IN ORDER TO MINIMIZE THE AMOUNT OF SCANNING. AND THIS LEARNED QUALITY OF FLOOD IS WHAT ALLOWS IT TO OUTPERFORM A LOT OF MORE TRADITIONAL INDEXES AND DATA LAYOUTS.
utt_0038 utt 181.91 190.50 -X NOW FLOOD DOES HAVE A COUPLE PRACTICAL LIMITATIONS, WHICH IS WHAT MOTIVATED US TO CREATE TSUNAMI. AND ONE OF THOSE LIMITATIONS IS THAT FLOOD CAN PERFORM POORLY
utt_0040 utt 190.67 201.33 -X IF THE QUERY WORKLOAD IS SKEWED. SO AS AN EXAMPLE HERE I'M SHOWING DATA WITH YEAR ON THE X-AXIS AND SALES ON THE Y-AXIS. I'M SHOWING A WORKLOAD WHERE EVERY QUERY IS DEPICTED AS A GREEN RECTANGLE.
utt_0042 utt 201.33 206.04 -X SO INTUITIVELY THIS WORKLOAD IS SKEWED IN TWO WAYS. FIRST, IT'S SKEWED IN TERMS OF FREQUENCY,
utt_0043 utt 206.04 209.05 -X IN THE SENSE THAT THE FREQUENCY OF QUERIES VARIES ACROSS THIS SPACE,
utt_0044 utt 209.05 218.30 -X BECAUSE QUERIES APPEAR MORE DENSELY AFTER two thousand and nineteen THAN BEFORE. AND THIS KIND OF TEMPORAL SKEWNESS IS VERY COMMON IN PRACTICE BECAUSE YOU'RE MORE LIKELY TO QUERY RECENT DATA THAN STALE DATA.
utt_0046 utt 219.19 228.92 -X AND SECOND, THE WORKLOAD IS ALSO SKEWED IN TERMS OF FILTER SELECTIVITY IN THE SENSE THAT THE PER DIMENSION FILTER SELECTIVITY OF THE AVERAGE QUERY VARIES ACROSS THIS SPACE.
utt_0048 utt 229.08 243.03 -X SO GIVEN THIS WORKLOAD, FLOOD WOULD CREATE A GRID LIKE THIS, WHICH DOESN'T PERFORM VERY WELL AS YOU CAN SEE VISUALLY BY THE FACT THAT THERE'S A LOT OF EXTRA SCANNING OF DATA OUTSIDE THE QUERY RECTANGLES. AND FUNDAMENTALLY, THE REASON FOR THIS BAD PERFORMANCE IS THAT FLOOD'S
utt_0051 utt 243.03 247.91 -X SINGLE UNIFORM GRID CAN ONLY OPTIMIZE FOR THE AVERAGE QUERY, WHICH RESULTS IN POOR PERFORMANCE
utt_0052 utt 248.24 256.15 -X IF THE WORKLOAD IS NOT UNIFORM, IN OTHER WORDS, IF THE WORKLOAD IS SKEWED. SO TSUNAMI, OUR NEW INDEX,
utt_0053 utt 256.15 266.34 -X IS ABLE TO ADAPT TO QUERIES SKEW AND OUR KEY IDEA IS TO DIVIDE DATA SPACE INTO DISJOINT REGIONS SO THAT WITHIN EACH REGION THE WORKLOAD IS NOT SKEWED. FOR EXAMPLE HERE I'VE DIVIDED DATA SPACE
utt_0055 utt 266.34 279.71 -X BASED ON WHETHER IT'S BEFORE OR AFTER two thousand and nineteen. THEN EACH REGION GETS ITS OWN INDEPENDENT GRID THAT'S SPECIALIZED FOR ONLY THE QUERIES THAT FALL IN THAT REGION. SO NOW USING TSUNAMI'S LAYOUT WE'RE ABLE TO RUN THIS WORKLOAD WHILE SCANNING MUCH LESS DATA THAN FLOOD.
utt_0058 utt 280.02 283.64 -X SO THAT'S THE CORE INTUITION BEHIND HOW TSUNAMI DEALS WITH QUERY SKEW.
utt_0059 utt 285.65 292.25 -X SO NOW I'M GOING TO MAKE THIS INTUITION MORE CONCRETE BY PRESENTING A SIMPLIFIED VERSION OF TSUNAMI'S ALGORITHM FOR FINDING THE BEST LAYOUT.
utt_0061 utt 292.76 307.61 -X SO STARTING WITH A FULL DATA SET AND A FULL QUERY WORKLOAD, THE FIRST STEP IS TO CLUSTER QUERIES INTO TYPES THAT HAVE SIMILAR SELECTIVITY CHARACTERISTICS. AND TO DO THAT WE'RE GOING TO GENERATE A VECTOR EMBEDDING FOR EVERY QUERY BASED ON ITS FILTER SELECTIVITY IN EACH DIMENSION.
utt_0064 utt 307.77 311.88 -X SO FOR EXAMPLE, THIS QUERY HERE WILL HAVE THE TWO-DIMENSIONAL VECTOR EMBEDDING OF zero point two five COMMA
utt_0065 utt 312.92 322.97 -X zero point zero six, AND THAT'S BECAUSE THE QUERY'S FILTER OVER YEAR SELECTS twenty-five PERCENT OF ALL THE DATA AND THE QUERY'S FILTER OVER SALES SELECTS SIX PERCENT OF ALL THE DATA. AND AS ANOTHER EXAMPLE,
utt_0067 utt 322.97 326.43 -X THIS TALL NARROW QUERY ON THE RIGHT WOULD HAVE A VECTOR EMBEDDING OF zero point zero two COMMA zero point five.
utt_0068 utt 328.31 333.40 -X SO EVERY EMBEDDED QUERY CAN BE REPRESENTED AS A POINT IN A TWO-DIMENSIONAL EMBEDDED SPACE.
utt_0069 utt 334.07 336.44 -X NOW THE SECOND STEP IS TO RUN A CLUSTERING ALGORITHM,
utt_0070 utt 336.44 339.42 -X WHICH IN OUR EXAMPLE FINDS THAT THERE'S TWO DISTINCT CLUSTERS,
utt_0071 utt 339.42 343.80 -X AND THE FINAL STEP IS TO MAP THESE CLUSTERS BACK TO THE ORIGINAL SPACE AND ASSIGN QUERY TYPES.
utt_0072 utt 344.18 354.81 -X SO THE PURPOSE OF CLUSTERING IS THAT NOW QUERIES BELONGING TO A SPECIFIC TYPE HAVE LOW SKEW IN TERMS OF SELECTIVITY, SO WITHIN EACH TYPE WE ONLY NEED TO ADDRESS SKEW IN TERMS OF FREQUENCY.
utt_0074 utt 356.70 361.31 -X NOW THE SECOND STEP IS TO DIVIDE DATA SPACE INTO DISJOINT REGIONS TO REDUCE QUERY SKEW.
utt_0075 utt 361.72 372.89 -X SO AS I'VE WRITTEN BELOW, QUERY SKEW IS FORMALLY DEFINED WITH RESPECT TO A CERTAIN DIMENSION I OVER A CERTAIN QUERY TYPE IN A CERTAIN RANGE BETWEEN A AND B. SO FOR EXAMPLE, LET'S SAY WE WANT TO
utt_0077 utt 372.89 377.60 -X FIND THE SKEW WITH RESPECT TO THE YEAR DIMENSION OVER THE GREEN QUERY TYPE BETWEEN two thousand and sixteen AND two thousand and twenty.
utt_0078 utt 378.94 382.73 -X SO THE FIRST THING WE NEED IS THE QUERY DENSITY DISTRIBUTION, WHICH I'VE SHOWN HERE
utt_0079 utt 382.94 387.49 -X AS A GREEN CURVE. YOU'LL NOTICE THAT THE CURVE IS HIGHER IN AREAS WHERE GREEN QUERIES ARE DENSER.
utt_0080 utt 388.12 391.61 -X THE SECOND THING WE NEED IS THE UNIFORM DISTRIBUTION OVER THE SAME RANGE,
utt_0081 utt 391.61 397.28 -X WHICH I'VE SHOWN AS A DASHED GRADE LINE. NOW BY DEFINITION THE UNIFORM DISTRIBUTION HAS NO SKEW,
utt_0082 utt 397.53 402.72 -X SO THE SKEW OF THE GREEN QUERY TYPE IS COMPUTED AS THE DISTANCE BETWEEN THE TWO DISTRIBUTIONS,
utt_0083 utt 402.72 406.11 -X WHICH YOU CAN INTUITIVELY VISUALIZE AS THE AREA OF THIS BLUE REGION.
utt_0084 utt 408.92 418.85 -X SO NOW WE CAN COMPUTE SKEW INDEPENDENTLY FOR THE PURPLE QUERIES AND SINCE THESE ARE THE ONLY TWO QUERY TYPES IN OUR WORKLOAD WE SUM THE INDIVIDUAL SKEWS TO FIND THE TOTAL SKEW WITH RESPECT TO THE
