utt_0000 utt 0.43 4.62 -X HI, I AM ANNA FARIHA FROM UNIVERSITY OF MASSACHUSETTS AMHERST.
utt_0001 utt 4.62 11.06 -X THIS IS A JOINT WORK WITH SUMAN NATH FROM MICROSOFT RESEARCH AND MY ADVISOR, PROFESSOR ALEXANDRA MELIOU
utt_0003 utt 11.53 18.86 -X TODAY, I AM GOING TO TALK ABOUT A DATA-DRIVEN DEBUGGING TECHNIQUE THAT EXPLAINS WHY DATA SYSTEMS FAIL INTERMITTENTLY.
utt_0005 utt 19.37 26.51 -X DATA MANAGEMENT SYSTEMS AND DATABASE-BACKED APPLICATIONS HEAVILY RELY ON ASYNCHRONOUS AND CONCURRENT PROCESSING.
utt_0007 utt 26.54 30.93 -X LIKE OTHER COMPLEX SYSTEMS, THESE SYSTEMS ALSO HAVE BUGS.
utt_0008 utt 31.18 36.15 -X BUGS CAUSE SERIOUS ISSUES LIKE DATA CORRUPTION, UNRESPONSIVENESS, AND CRASH.
utt_0009 utt 36.49 41.36 -X A NOTORIOUS KIND OF BUGS ARE THOSE, THAT MANIFEST ONLY INTERMITTENTLY.
utt_0010 utt 41.68 47.95 -X EVEN FOR THE SAME INPUT, AN INTERMITTENTLY FAILING APPLICATION SOMETIMES FAILS AND SOMETIMES SUCCEEDS.
utt_0011 utt 48.17 58.13 -X THE SUCCESS OR FAILURE HERE DEPENDS NOT ONLY ON THE INPUT, BUT ALSO DUE TO RANDOMNESS OF THE RUNTIME CONDITIONS, SUCH AS, THREAD SCHEDULING AND TIMING.
utt_0013 utt 58.13 62.64 -X AND THAT'S WHY INTERMITTENT BUGS ARE HARD TO REPRODUCE AND VERY HARD DEBUG.
utt_0014 utt 62.77 68.75 -X OUR GOAL IS TO INVESTIGATE THE ROOT CAUSES OF THESE HARD-TO-CATCH INTERMITTENT FAILURES.
utt_0015 utt 68.97 73.68 -X I WILL NOW GIVE AN EXAMPLE OF INTERMITTENT FAILURE IN NPGSQL.
utt_0016 utt 74.25 77.23 -X IT IS AN ADO.NET DATA PROVIDER FOR POSTGRES.
utt_0017 utt 77.23 83.86 -X SO IN NPGSQL'S DATABASE CONNECTION MANAGER MODULE, TWO THREADS SHARE A GLOBAL ARRAY CALLED POOLS.
utt_0018 utt 83.86 87.09 -X POOLS KEEPS TRACK OF THE ACTIVE DATABASE CONNECTIONS.
utt_0019 utt 87.09 94.16 -X THE VARIABLE LAST SLOT IS ALSO SHARED, AND IT STORES THE LAST USED INDEX WITHIN THE POOLS ARRAY.
utt_0020 utt 94.16 96.60 -X THE FIND FUNCTION RUNS IN THREAD one.
utt_0021 utt 96.75 101.78 -X GIVEN A CONNECTION KEY, FIND RETURNS ITS INDEX WITHIN THE POOLS ARRAY.
utt_0022 utt 101.94 105.91 -X FOR EXAMPLE, FOR KEY fifty-six, FIND WILL RETURN two.
utt_0023 utt 106.26 109.81 -X IF THE KEY IS NOT FOUND, FIND WILL RETURN NULL.
utt_0024 utt 110.03 115.25 -X FOR SEARCHING A KEY, FIND FIRST COPIES THE SHARED ARRAY INTO A LOCAL ARRAY.
utt_0025 utt 115.25 121.30 -X THEN IT SEARCHES IN THE LOCAL ARRAY UNTIL IT FINDS THE KEY, OR REACHES THE LAST SLOT INDEX.
utt_0026 utt 121.30 123.22 -X THE ADD FUNCTION IS IN THREAD two.
utt_0027 utt 123.66 128.34 -X GIVEN A NEW KEY, THE ADD FUNCTION INSERTS THE KEY TO THE POOLS ARRAY.
utt_0028 utt 128.34 133.62 -X FOR INSERTING THE KEY, ADD FIRST CHECKS IF THE POOLS ARRAY IS ALREADY AT CAPACITY.
utt_0029 utt 133.75 139.38 -X IF THERE IS NO MORE ROOM IN THE POOLS ARRAY FOR THE NEW KEY, ADD DOUBLES THE POOL SIZE.
utt_0030 utt 139.67 144.41 -X IT THEN INCREASES LAST SLOT BY ONE, AND STORES THE NEW KEY THERE.
utt_0031 utt 144.41 147.73 -X SO LET'S TALK ABOUT AN INTERMITTENT BUG IN NPGSQL.
utt_0032 utt 147.73 150.01 -X THIS WAS REPORTED LAST YEAR DURING MAY.
utt_0033 utt 150.01 154.49 -X THIS IS HOW THE BUG HAPPENS: SO FIND WANTS TO FIND INDEX OF A KEY.
utt_0034 utt 154.55 160.18 -X FOR THAT, IT FIRST COPIES POOLS INTO LOCAL MEMORY, RIGHT AFTER THAT, THE ADD FUNCTION,
utt_0035 utt 160.18 165.11 -X IN ANOTHER THREAD, ADDS A NEW KEY TO POOLS, WHICH REQUIRES RESIZING POOLS.
utt_0036 utt 165.27 168.18 -X SO NOW, LAST SLOT INDICATES INDEX five.
utt_0037 utt 169.07 173.72 -X NOW WHEN FIND GETS BACK TO WORK, IT STARTS SEARCHING LOCALPOOLS.
utt_0038 utt 173.84 178.81 -X SINCE LAST SLOT IS NOW five, IT WILL HIT INDEX five, IN THE LOCALPOOLS.
utt_0039 utt 178.83 181.24 -X BUT LOCALPOOLS HAS NO SUCH INDEX.
utt_0040 utt 181.24 185.50 -X SO IT WILL THROW AN ARRAY INDEX OUT OF BOUND EXCEPTION, AND THE PROGRAM WILL CRASH.
utt_0041 utt 186.13 191.74 -X THIS ISSUE ARISES ONLY WHEN THIS SPECIFIC INTERLEAVING HAPPENS WITHIN THE TWO THREADS.
utt_0042 utt 191.74 196.38 -X SPECIFICALLY, AT FIRST, ADD TEMPORALLY OVERLAPS WITH FIND.
utt_0043 utt 196.38 200.98 -X WHICH CAUSES FIND TO MAKE AN ATTEMPT TO ACCESS AN INVALID ARRAY INDEX.
utt_0044 utt 200.98 206.33 -X THIS CAUSES AN ARRAY INDEX OUT OF BOUND EXCEPTION, AND IT FINALLY CRASHES THE PROGRAM.
utt_0045 utt 206.39 208.98 -X ALL OF THESE EVENTS CAUSE THIS FAILURE.
utt_0046 utt 209.04 214.07 -X NOW WE WANT IDENTIFY TWO THINGS: NUMBER ONE, THE ROOT CAUSE OF THE FAILURE.
utt_0047 utt 214.07 219.26 -X AND NUMBER TWO, AN EXPLANATION THAT TELLS US HOW THE ROOT CAUSE TRIGGERS THE FAILURE.
utt_0048 utt 219.32 223.54 -X IN THIS WORK, WE CALL ALL THESE RUNTIME EVENTS PREDICATES.
utt_0049 utt 223.60 229.21 -X THERE ARE MANY TECHNIQUES FOR ROOT CAUSE ANALYSIS SUCH AS STATIC AND DYNAMIC PROGRAM ANALYSIS,
utt_0050 utt 229.21 230.87 -X BUT THESE ARE HEAVY-WEIGHT TECHNIQUES.
utt_0051 utt 230.90 237.63 -X WE WANTED TO SOLVE THE PROBLEM IN A DATA-DRIVEN MANNER, BECAUSE IT'S LIGHT-WEIGHT AND GENERALIZES TO ANY PLATFORM.
utt_0053 utt 237.69 243.35 -X STATISTICAL DEBUGGING IS ONE SUCH DATA-DRIVEN TECHNIQUE THAT PARTIALLY ADDRESSES OUR PROBLEM.
utt_0054 utt 243.61 248.22 -X IT REPORTS PREDICATES THAT ARE HIGHLY CORRELATED WITH FAILURE AS POTENTIAL ROOT CAUSES.
utt_0055 utt 248.44 256.06 -X BUT STATISTICAL DEBUGGING IS BASED ON JUST CORRELATION, AND ALL OF US KNOW THAT CORRELATION DOESN'T IMPLY CAUSATION.
utt_0057 utt 256.06 259.64 -X SPECIFICALLY, THERE ARE TWO MAIN LIMITATIONS OF STATISTICAL DEBUGGING.
utt_0058 utt 259.64 269.15 -X FIRST, IT PRODUCES A LONG LIST OF CORRELATED PREDICATES, AND ULTIMATELY RELIES ON THE DEVELOPER TO INVESTIGATE THIS LONG LIST OF PREDICATES, MANUALLY.
utt_0060 utt 269.21 273.63 -X AND SECOND, IT DOES NOT EXPLAIN HOW A ROOT CAUSE TRIGGERS THE FAILURE.
utt_0061 utt 273.63 287.87 -X SO IN THIS WORK, WE HAVE TWO GOALS: FIRST, TO PIN-POINT AND ISOLATE THE TRUE ROOT CAUSE OF THE INTERMITTENT FAILURE, AND SECOND, TO CONNECT THE DOTS FROM THE ROOT CAUSE TO THE FAILURE WITH A SET OF CAUSALLY CONNECTED INTERMEDIATE PREDICATES.
utt_0064 utt 287.87 293.79 -X THIS CHAIN OF PREDICATES EXPLAINS HOW THE ROOT CAUSE TRIGGERS THE FAILURE MORE PRECISELY.
utt_0065 utt 293.79 297.28 -X NOW I AM GOING TO TALK ABOUT HOW WE ACHIEVE THESE TWO GOALS.
utt_0066 utt 297.34 304.70 -X OUR APPROACH AID IS BUILT ON four EXISTING TECHNIQUES, AND COMBINES THEM IN A NOVEL WAY TO ACHIEVE OUR GOALS.
utt_0068 utt 304.86 312.76 -X GIVEN AN APPLICATION THAT FAILS INTERMITTENTLY, AID FIRST USES STATISTICAL DEBUGGING TO FIND A LIST OF CANDIDATE PREDICATES.
utt_0070 utt 312.79 320.86 -X AID THEN USES CAUSALITY PRINCIPLES TO MAKE AN INITIAL GUESS ABOUT THE CAUSAL RELATIONSHIPS OF THESE CANDIDATE PREDICATES.
utt_0072 utt 320.98 325.02 -X AID THEN VERIFIES CAUSALITY BY ACTUALLY TWEAKING THE PREDICATES.
utt_0073 utt 325.02 328.76 -X FOR TWEAKING PREDICATES, AID INJECTS FAULTS TO THE SOURCE CODE.
utt_0074 utt 329.21 338.33 -X TO EXPEDITE ROOT-CAUSE ANALYSIS, INSTEAD OF TWEAKING ONE PREDICATE AT A TIME, AID USES GROUP TESTING, AND TWEAKS MULTIPLE PREDICATES SIMULTANEOUSLY.
utt_0076 utt 338.71 342.62 -X BASED ON THE OUTCOMES OF ONE ROUND, AID PLANS FOR THE NEXT ROUND.
utt_0077 utt 342.62 347.71 -X AID REPEATS THESE STEPS UNTIL IT PIN POINTS THE ROOT CAUSE AND EXPLANATION OF THE FAILURE.
utt_0078 utt 348.63 351.13 -X LET'S TALK FINDING THE CANDIDATE PREDICATES.
utt_0079 utt 351.13 356.80 -X WE FIRST INSTRUMENT THE SOURCE CODE TO GENERATE EXECUTION LOGS WHEN THE PROGRAM EXECUTES,
utt_0080 utt 356.80 359.29 -X AND FROM THE EXECUTION LOGS, WE EXTRACT PREDICATES.
utt_0081 utt 359.67 368.51 -X THEN, WE USE STATISTICAL DEBUGGING TO FIND PREDICATES THAT ARE HIGHLY CORRELATED WITH THE FAILURE BUT RARELY OBSERVED IN THE SUCCESSFUL EXECUTIONS.
utt_0083 utt 368.57 371.61 -X AID USES THESE PREDICATES AS CANDIDATES.
utt_0084 utt 372.19 377.63 -X AID'S NEXT STEP IS TO FIND OUT, WITHIN THE CANDIDATE PREDICATES, WHAT IS CAUSING WHAT.
utt_0085 utt 377.63 383.68 -X THE CANDIDATE PREDICATE SET CAN BE VERY LARGE AND CHECKING ALL PAIR CAUSAL RELATIONSHIPS IS TOO EXPENSIVE.
utt_0087 utt 383.74 387.36 -X SO AID FIRST APPROXIMATES THEIR CAUSAL RELATIONSHIP.
utt_0088 utt 387.51 397.02 -X SINCE A CAUSE MUST TEMPORALLY PRECEDE AN EFFECT, WE CAN USE TEMPORAL PRECEDENCE GRAPH OF THE PREDICATES TO APPROXIMATE THEIR CAUSAL RELATIONSHIPS.
utt_0090 utt 397.05 402.66 -X SINCE A PROGRAM CANNOT GO BACK IN TIME, THIS GRAPH WILL ALWAYS BE A DIRECTED ACYCLIC GRAPH.
utt_0091 utt 402.66 409.98 -X FOR EXAMPLE, IN THIS TEMPORAL PRECEDENCE GRAPH, THERE IS A PATH FROM Pone TO Peight AND THIS IMPLIES THAT Pone MAY CAUSE Peight.
utt_0093 utt 411.87 416.38 -X ON THE OTHER HAND, THERE IS NO PATH FROM Pfour TO Pnine, SO Pfour CANNOT CAUSE Pnine.
utt_0094 utt 418.01 423.01 -X TEMPORAL PRECEDENCE IS NECESSARY FOR CAUSATION, BUT IT IS NOT SUFFICIENT.
utt_0095 utt 423.01 430.34 -X THERE EXIST MANY DIFFERENT NOTIONS FOR CAUSALITY IN THE LITERATURE, BUT IN THIS PAPER, WE ADAPT COUNTERFACTUAL CAUSALITY.
utt_0097 utt 430.34 436.22 -X COUNTERFACTUAL CAUSALITY SAYS THAT IF STOPPING AN EVENT C, STOPS ANOTHER EVENT E,
utt_0098 utt 436.32 442.37 -X THEN C IS A COUNTERFACTUAL CAUSE OF E. SO HOW CAN WE VERIFY COUNTERFACTUAL CAUSALITY?
utt_0099 utt 442.37 446.24 -X TO VERIFY COUNTERFACTUAL CAUSALITY, WE APPLY INTERVENTIONS.
utt_0100 utt 446.37 455.07 -X INTERVENING ON A PREDICATE ALTERS ITS BEHAVIOR DURING RUNTIME, SO THAT IT BEHAVES EXACTLY LIKE THE SUCCESSFUL EXECUTIONS.
utt_0102 utt 455.07 460.48 -X THE KEY IDEA IS TO CHECK IF INTERVENING ON A PREDICATE ALWAYS STOPS THE FAILURE.
utt_0103 utt 460.48 465.67 -X IF IT DOES, ACCORDING TO COUNTERFACTUAL CAUSALITY, IT IS A TRUE ROOT CAUSE OF THE FAILURE.
utt_0104 utt 466.08 469.06 -X SO HOW CAN WE IMPLEMENT THESE RUNTIME INTERVENTIONS?
utt_0105 utt 469.09 476.51 -X AID USES AN EXISTING TECHNIQUE THAT INJECTS FAULTS TO A PROGRAM, TO MAKE IT BEHAVE IN A CERTAIN WAY.
utt_0107 utt 476.86 488.99 -X FOR EXAMPLE, TO PREVENT TEMPORAL OVERLAP BETWEEN FIND AND ADD, AID INJECTS LOCKS AROUND BOTH FIND AND ADD TO ENSURE THEIR MUTUAL EXCLUSION DURING RUNTIME.
utt_0109 utt 488.99 494.40 -X IF WE INTERVENE ON ONE PREDICATE AT A TIME, IT WILL REQUIRE A LARGE AMOUNT OF ITERATIONS,
utt_0110 utt 494.50 500.71 -X SINCE EACH INTERVENTION ROUND REQUIRES GOING THROUGH ALL OF THESE STEPS, THIS IS QUITE EXPENSIVE.
utt_0111 utt 500.86 505.70 -X TO REDUCE THE NUMBER OF INTERVENTIONS, AID USES GROUP TESTING.
utt_0112 utt 505.70 510.98 -X SO WHAT DO YOU DO WHEN THERE ARE NOT ENOUGH TEST KITS FOR, SAY COVID TESTING?
utt_0113 utt 510.98 517.89 -X WELL, WHEN TESTING ON EACH INDIVIDUAL IS NOT FEASIBLE, GROUP TESTING IS AN ALTERNATIVE AND CHEAPER OPTION!
utt_0115 utt 517.89 522.50 -X IN GROUP TESTING, INSTEAD OF TESTING EACH INDIVIDUALS, WE TEST ON GROUPS.
utt_0116 utt 522.50 528.23 -X FOR EXAMPLE, WE CAN MIX BLOOD SAMPLES OF A GROUP OF PEOPLE, AND THEN TEST THE MIXTURE.
utt_0117 utt 528.64 531.08 -X AID USES ADAPTIVE GROUP TESTING.
utt_0118 utt 531.08 538.37 -X IN ADAPTIVE GROUP TESTING, WHEN RESULT OF AN ENTIRE GROUP IS NEGATIVE, WE CAN DECLARE THAT ALL OF THEM HAVE TESTED NEGATIVE.
utt_0120 utt 538.46 543.24 -X OTHERWISE, WE KEEP SPLITTING THE GROUP UNTIL WE REACH CERTAIN CONCLUSION.
utt_0121 utt 543.24 548.97 -X SO WHAT TO TEST NEXT IS ADAPTIVELY DECIDED DEPENDING ON THE RESULTS OF PREVIOUS TESTS,
utt_0122 utt 548.97 551.72 -X AND THIS REDUCES THE NUMBER OF TESTS REQUIRED.
utt_0123 utt 551.72 560.52 -X FOLLOWING THIS IDEA OF ADAPTIVE GROUP TESTING, AID APPLIES ADAPTIVE GROUP INTERVENTION ON PREDICATES TO REDUCE THE NUMBER OF INTERVENTION ROUNDS.
utt_0125 utt 560.87 566.44 -X IN TRADITIONAL GROUP TESTING, INTERVENTION ON A GROUP ONLY GIVES INFORMATION ABOUT THAT GROUP,
utt_0126 utt 566.44 568.71 -X BUT TELLS NOTHING ABOUT THE OTHER GROUPS.
utt_0127 utt 568.71 575.14 -X BUT OUR SETTING IS SLIGHTLY DIFFERENT AND WE HAVE A TEMPORAL PRECEDENCE GRAPH AS AN EXTRA PIECE OF INFORMATION.
utt_0129 utt 575.23 580.42 -X AID EXPLOITS THIS TO FURTHER PRUNE PREDICATES BEYOND TRADITIONAL GROUP TESTING.
utt_0130 utt 580.42 588.04 -X TRIVIALLY, IF A PREDICATE IS DISABLED BY INTERVENTION, BUT THE PROGRAM STILL FAILS, THAT PREDICATE CANNOT BE THE ROOT CAUSE.
utt_0132 utt 588.04 592.29 -X SO AID ELIMINATES THAT PREDICATE JUST LIKE ADAPTIVE GROUP TESTING.
utt_0133 utt 592.29 599.98 -X FURTHER, IF INTERVENING ON A PREDICATE DISABLES SOME OTHER PREDICATE THAT APPEAR TEMPORALLY LATER, BUT THE FAILURE IS STILL THERE.
utt_0135 utt 599.98 605.51 -X THIS MEANS THAT THE OTHER PREDICATE IS BEING CAUSED BY THE PREDICATE UNDER INTERVENTION,
utt_0136 utt 605.51 607.91 -X AND HAS NOTHING TO DO WITH THE ACTUAL FAILURE.
utt_0137 utt 608.13 614.76 -X SO AID PRUNES THESE OTHER PREDICATES AS WELL BUT CLASSICAL GROUP TESTING CANNOT DO THIS KIND OF PRUNING.
utt_0139 utt 614.76 621.06 -X I AM DONE TALKING ABOUT THE THE TECHNICAL DETAILS OF AID AND I WILL NOW PROCEED TO PRESENT OUR EVALUATION RESULTS.
utt_0141 utt 621.76 628.01 -X WE EVALUATED AID ON SIX REAL-WORLD INTERMITTENTLY FAILING APPLICATIONS WITH DIFFERENT ROOT CAUSES.
utt_0142 utt 628.07 633.16 -X FOR ALL OF THEM, AID SUCCESSFULLY FOUND THE ROOT CAUSE AND THE CORRECT EXPLANATION.
utt_0143 utt 633.16 641.35 -X HERE, YOU CAN SEE THAT THE NUMBER OF PREDICATES REPORTED BY STATISTICAL DEBUGGING IS MUCH MORE THAN THE NUMBER OF PREDICATES IN THE ACTUAL CAUSAL CHAIN.
utt_0145 utt 641.60 645.86 -X THIS IS BECAUSE STATISTICAL DEBUGGING REPORTS MANY FALSE POSITIVES.
utt_0146 utt 645.86 650.06 -X BUT AID ALWAYS FOUND THE PREDICATES IN THE ACTUAL CAUSAL CHAIN CORRECTLY.
utt_0147 utt 650.06 655.69 -X THIS CHART SHOWS THE NUMBER OF REQUIRED INTERVENTIONS IN ADAPTIVE GROUP TESTING VS AID.
utt_0148 utt 655.81 662.76 -X AID'S PREDICATE PRUNING SIGNIFICANTLY REDUCED THE NUMBER OF INTERVENTIONS COMPARED TO ADAPTIVE GROUP TESTING.
utt_0150 utt 662.76 674.47 -X APART FROM THE GREAT EMPIRICAL FINDINGS, WE ALSO THEORETICALLY ESTABLISH THAT AID'S PROBLEM SETTING ALLOWS SMALLER SEARCH SPACE AND AID REQUIRES MUCH FEWER INTERVENTIONS THAT TRADITIONAL
utt_0152 utt 674.47 678.95 -X ADAPTIVE GROUP TESTING AND A LOWER INFORMATION THEORETIC LOWER BOUND.
utt_0153 utt 678.95 681.51 -X PLEASE REFER TO OUR PAPER FOR MORE DETAILS ON THIS.
utt_0154 utt 681.51 686.28 -X TO SUMMARIZE, AID IS A DATA-DRIVEN TECHNIQUE FOR DEBUGGING INTERMITTENT FAILURES.
utt_0155 utt 686.28 691.85 -X IT PRODUCES CAUSALLY VERIFIED ROOT CAUSE AND EXPLANATION CHAIN OF INTERMITTENT FAILURES.
utt_0156 utt 692.01 698.70 -X AID IS MORE ACCURATE THAN STATISTICAL DEBUGGING, AND MORE EFFICIENT THAN CLASSICAL ADAPTIVE GROUP TESTING.
utt_0158 utt 698.70 699.88 -X THANK YOU FOR LISTENING.
utt_0159 utt 699.88 703.44 -4.8707 WE WILL BE HAPPY TO ANSWER ANY QUESTIONS THROUGH THE COMMUNICATION CHANNEL.
