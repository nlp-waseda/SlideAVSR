utt_0000 utt 5.39 19.22 -X HELLO, EVERYONE. MY NAME IS FENG ZHANG. I AM GOING TO PRESENT OUR RECENT WORK ON ENABLING EFFICIENT COMPRESSED DATA DIRECT PROCESSING FOR VARIOUS DATABASES. THIS IS A JOINT WORK
utt_0002 utt 19.22 24.18 -X OF RENMIN UNIVERSITY OF CHINA, TSINGHUA UNIVERSITY, AND TENCENT.
utt_0003 utt 27.79 36.50 -X THIS IS THE OUTLINE OF OUR PRESENTATION. FIRST, LET‚ÄôS LOOK AT OUR MOTIVATION.
utt_0004 utt 36.69 50.48 -X THE FIRST MOTIVATION IS THE four V‚ÄôS OF BIG DATA. BIG DATA ENVIRONMENT HAS THE FOUR BASIC CHARACTERISTICS: VOLUME, VARIETY, VELOCITY AND VERACITY.
utt_0006 utt 52.59 61.01 -X DUE TO THE BIG DATA CHARACTERISTICS, THE CURRENT DATABASE SYSTEMS BECOME RATHER DIVERSE. FOR
utt_0007 utt 61.01 70.88 -X EXAMPLE, TRADITIONAL DATABASE SYSTEMS INCLUDE TDSQL, MYSQL, TIDB, HBASE, SQL SERVER, REDIS
utt_0008 utt 70.88 82.35 -X AND SO ON. THEN, WE HAVE NOSQL DATABASE SYSTEMS, INCLUDING AMAZON DYNAMODB, COUCHDB, AND MONGODB.
utt_0010 utt 92.72 101.43 -X AND CLOUD ENVIRONMENTS, WE HAVE MPP DATABASE SYSTEMS AND CLOUD DATABASE SYSTEMS. FOR EXAMPLE,
utt_0011 utt 102.06 108.92 -X WE HAVE MPP DATABASE SYSTEMS SUCH AS GREENPLUM AND HAWQ, AND WE HAVE CLOUD DATABASE SYSTEMS
utt_0012 utt 109.01 120.15 -X SUCH AS AMAZON AURORA AND SNOWFLAKE. FACING THESE VARIOUS DATABASES, HOW TO ADDRESS THE BIG DATA PROBLEM BECOMES A CHALLENGE.
utt_0014 utt 122.61 129.30 -X COMPRESSION-BASED DIRECT PROCESSING VIA RULE-BASED COMPRESSION IS A COMPUTING PARADIGM WE PROPOSED
utt_0015 utt 130.74 142.90 -X IN VLDB two thousand and eighteen, WHICH CAN BE EXPLAINED FROM THREE LEVELS: ELEMENTS, RULES, AND DAG. ELEMENT IS THE SMALLEST INDIVISIBLE MINIMUM PROCESSING UNIT.
utt_0017 utt 143.09 151.45 -X FOR EXAMPLE, IN FIGURE (A), EACH SYMBOL REPRESENTS A MINIMAL DATA UNIT. RULE IS A STRING OF ELEMENTS.
utt_0018 utt 151.95 159.38 -X WE USE A RULE TO REPRESENT REPEATED CONTENT, AND A RULE CONSISTS OF SUBRULES AND DATA UNITS.
utt_0019 utt 159.57 165.30 -X FOR EXAMPLE, IN FIGURE (B),ùëÖùëñ REPRESENTS A RULE.
utt_0020 utt 166.10 179.41 -X DAG IS THE RULE-COMPRESSED REPRESENTATION. THE RELATIONS BETWEEN DIFFERENT RULES CAN BE ORGANIZED AS A DAG, AS SHOWN IN FIGURE (C). WE CAN GIVE EACH SYMBOL AND RULE A NUMBER
utt_0022 utt 179.41 187.06 -X FOR NUMERICAL REPRESENTATION, AS SHOWN IN FIGURE (D). THEN, THE ORIGINAL DATA ARE REPRESENTED
utt_0023 utt 187.06 201.33 -X AS A SEQUENCE OF NUMBERS, AS SHOWN IN FIGURE (E). BASED ON THE RULE REPRESENTATION, WE CAN PERFORM COMMON DATA ANALYTICS DIRECTLY ON THE RULE COMPRESSED DATA. IN THIS PAPER,
utt_0025 utt 201.36 206.68 -X WE ARE TRYING TO APPLY SUCH RULE-BASED COMPRESSION TO BIG DATA SYSTEMS.
utt_0026 utt 209.08 217.88 -X WE DEVELOP A NEW STORAGE ENGINE, CALLED COMPRESSDB, WHICH CAN PERFORM DATA PROCESSING FOR DATABASES
utt_0027 utt 217.88 224.34 -X WITHOUT DECOMPRESSION. SINCE LARGE DATA ARE USUALLY STORED IN DISK,
utt_0028 utt 225.14 239.54 -X OUR IDEA IS TO DEVELOP RANDOM UPDATE OVER COMPRESSED DATA IN STORAGE LAYER BASED ON RULE COMPRESSION. IN DETAIL, AS SHOWN IN THE RIGHT FIGURE, IN AN OPERATING SYSTEM, THE
utt_0030 utt 239.54 248.15 -X LOWER LAYER IS THE STORAGE SYSTEMS, SUCH AS FUSE AND MOOSEFS. BASED ON THESE STORAGE SYSTEMS,
utt_0031 utt 248.37 257.83 -X WE BUILD DATABASES SUCH AS SQLITE, CLICKHOUSE, LEVELDB, AND MONGODB, AND THESE DATABASE SYSTEMS
utt_0032 utt 257.83 266.01 -X CAN PROVIDE SERVICE TO UPPER-LEVEL APPLICATIONS. THEREFORE, IF WE CAN INTEGRATE COMPRESSDB
utt_0033 utt 266.07 275.48 -X TO STORAGE LAYER, THEN IT CAN SUPPORT DIVERSE SYSTEMS! HOWEVER, IN DEVELOPING OUR IDEA,
utt_0034 utt 275.48 280.03 -X WE MEET THE FOLLOWING THREE CHALLENGES.
utt_0035 utt 280.82 290.11 -X THE FIRST CHALLENGE IS IN ELEMENT LEVEL. COMPLEXITIES EXIST IN USING LARGE ELEMENT GRANULARITY.
utt_0036 utt 290.77 299.56 -X PREVIOUS TADOC PROCESSES DATA AT WORD GRANULARITY, WHILE THE STORAGE SYSTEMS USUALLY ORGANIZE
utt_0037 utt 299.56 309.42 -X DATA AT A MUCH LARGER BLOCK GRANULARITY, SUCH AS oneKB OR fourKB. SIMPLY INCREASING THE PROCESSING
utt_0038 utt 309.42 318.23 -X GRANULARITY CAN REDUCE THE COMPRESSION EFFECT, BECAUSE TWO LARGE DATA BLOCKS CAN HAVE PART OF THE SAME DATA.
utt_0040 utt 320.53 333.15 -X THE SECOND CHALLENGE IS IN RULE LEVEL: WE NEED TO OPERATE RULES FOR RANDOM UPDATE. RANDOM UPDATES INVOLVE GREAT DIFFICULTIES TO HANDLE, ESPECIALLY DEALING WITH A LARGE AMOUNT OF
utt_0042 utt 333.15 340.80 -X RULES. IN DETAIL, RANDOM UPDATE ON HIERARCHICALLY COMPRESSED DATA NEEDS RECURSIVE RULE SPLIT,
utt_0043 utt 340.98 345.88 -X WHICH IS EXTREMELY INEFFICIENT WHEN THE DAG IS DEEP.
utt_0044 utt 346.17 359.04 -X THE THIRD CHALLENGE IS IN DAG LEVEL, WHICH IS PERFORMANCE MAINTENANCE OF REAL-TIME OPERATION ON THE DAG IN STORAGE LAYER. WHEN WE DEVELOP RANDOM UPDATES OVER COMPRESSED
utt_0046 utt 359.04 373.69 -X DATA IN STORAGE LAYER ON THE FLY, THE OPERATIONS ALSO NEED TO BE IMPLEMENTED IN THE STORAGE LAYER FOR EFFICIENCY. BECAUSE THE ACCESS SPEED OF THE DISK IS MUCH LOWER THAN THE MEMORY
utt_0048 utt 373.69 383.87 -X SPEED, WE NEED TO GUARANTEE THAT THE AMOUNT OF DATA TAKEN FROM DISK BY RANDOM ACCESS IS AS SMALL AS POSSIBLE.
utt_0050 utt 383.87 389.69 -X DESPITE THESE CHALLENGES, WE STILL DECIDE TO DEVELOP COMPRESSDB IN THE STORAGE LAYER,
utt_0051 utt 389.69 397.89 -X BECAUSE STORAGE SPACE IS MUCH LARGER THAN MEMORY SIZE. ACCORDINGLY, AN ELEMENT IN COMPRESSDB
utt_0052 utt 397.89 405.15 -X REPRESENTS A DATA UNIT LIKE A DATA BLOCK, A RULE REPRESENTS REPEATED CONTENT CONSISTING
utt_0053 utt 405.15 413.76 -X OF ELEMENTS AND SUBRULES, AND DAG IS THE ORGANIZATION OF RULES, AS DISCUSSED IN PREVIOUS SLIDES.
utt_0054 utt 413.91 428.16 -X AS FOR OUR NOVELTIES, IN ELEMENT LEVEL, WE INTRODUCE THE CONCEPT OF DATA HOLES TO ALLOW UPDATES IN LARGE DATA BLOCKS. IN RULE LEVEL, WE DEVELOP HASHING AND COUNTING DATA STRUCTURES
utt_0056 utt 428.16 435.90 -X FOR EFFICIENTLY LOCATING RULES. IN DAG LEVEL, WE LIMIT THE DEPTH OF THE DAG TO RETAIN THE
utt_0057 utt 435.90 443.39 -X COST OF RULE SPLIT AND MERGE WITHIN A SMALL RANGE. SUCH A DESIGN IS OF GREAT BENEFITS
utt_0058 utt 443.42 457.34 -X TO DATABASE APPLICATIONS, AND CAN SOLVE THE CHALLENGES MENTIONED IN PREVIOUS SLIDES. DATABASE SYSTEMS BUILT ON OUR STORAGE ENGINE CAN ENJOY THE TIME AND SPACE BENEFITS OF COMPRESSED
utt_0060 utt 457.34 459.97 -X DATA DIRECT PROCESSING.
utt_0061 utt 461.28 469.42 -X WE SHOW THE OVERVIEW OF OUR STORAGE ENGINE, COMPRESSDB, IN THIS SLIDE, WHICH CAN SUPPORT
utt_0062 utt 469.42 478.34 -X VARIOUS DATABASE SYSTEMS. COMPRESSDB CONSISTS OF THREE MAJOR MODULES: DATA STRUCTURE MODULE,
utt_0063 utt 478.49 486.27 -X COMPRESSION MODULE, AND OPERATION MODULE. THESE THREE MODULES SUPPORT THE DATABASE SYSTEMS
utt_0064 utt 486.33 494.26 -X BUILT ON OUR STORAGE ENGINE. THE FIRST DATA STRUCTURE MODULE PROVIDES NECESSARY DATA STRUCTURES
utt_0065 utt 494.26 508.48 -X TO BOTH THE COMPRESSION MODULE AND THE OPERATION MODULE. THE SECOND COMPRESSION MODULE SUPPORTS HIERARCHICALLY-COMPRESSION IN FILE SYSTEMS AND CAN BE APPLIED TO VARIOUS BLOCK-BASED
utt_0067 utt 508.48 516.29 -X FILE SYSTEMS. THE THIRD OPERATION MODULE CAN PUSH DOWN USER OPERATIONS TO FILE SYSTEMS.
utt_0068 utt 519.49 534.08 -X NEXT, WE SHOW OUR SYSTEM DESIGN. THE DATA STRUCTURE MODULE PROVIDES NECESSARY DATA STRUCTURES TO BOTH THE COMPRESSION MODULE AND THE OPERATION MODULE. FOR EXAMPLE, THE BLOCKHASHTABLE DATA
utt_0070 utt 534.08 546.88 -X STRUCTURE PROVIDES THE MAPPING FROM THE HASH VALUE OF A BLOCK TO ITS BLOCK NUMBER. THE BLOCKREFCOUNT DATA STRUCTURE RECORDS THE NUMBER OF TIMES A BLOCK IS REFERENCED IN THE FILE
utt_0072 utt 546.88 556.77 -X SYSTEM. THE BLOCKHOLE DATA STRUCTURE PROVIDES THE NECESSARY INFORMATION IN UPDATE OPERATIONS WHEN ‚ÄúBLOCK HOLE‚Äù IS GENERATED.
utt_0074 utt 557.66 571.78 -X FOR THE COMPRESSION MODULE, OUR GENERAL DESIGN IS THAT WHEN DATA ARE INPUT INTO COMPRESSDB FOR THE FIRST TIME, WE USE OUR RULE BASED METHOD TO COMPRESS THE FILE TO THE SYSTEM.
utt_0076 utt 572.03 582.69 -X IN DETAIL, WE REGARD EACH BLOCK AS A NODE. THE INDIRECT NODES REPRESENT RULES WHILE THE DATA NODES REPRESENT LEAVES.
utt_0078 utt 583.39 592.04 -X FOR THE OPERATION MODULE, WE DEVELOP OPERATIONS INCLUDING EXTRACT, REPLACE, INSERT, DELETE,
utt_0079 utt 592.04 606.32 -X SEARCH, AND COUNT, AND THEY CAN BE PUSHED DOWN TO THE STORAGE LAYER. THE OPERATION PUSH-DOWN REFERS TO THAT THE DATA PROCESSING HAPPENS DIRECTLY IN THE FILE SYSTEM LAYER, WHICH IS
utt_0081 utt 606.32 613.09 -X A LOWER SOFTWARE LAYER. IT ALLOWS THE DIRECT PROCESSING TECHNIQUES TO OCCUR CLOSER TO DATA,
utt_0082 utt 613.82 625.73 -X WITH WHICH COMPRESSDB CAN SIGNIFICANTLY REDUCE THE AMOUNT OF DATA ACCESSES TO DISK AND ACCELERATE ALL UPPER-LEVEL DATABASE APPLICATIONS.
utt_0084 utt 626.95 635.86 -X IN OUR IMPLEMENTATION, WE DEVELOP COMPRESSDB IN REAL STORAGE SYSTEMS, INCLUDING FUSE AND
utt_0085 utt 636.16 645.75 -X MOOSEFS, ALONG WITH A SET OF OPRATIONS. DATABASES CAN SEAMLESSLY USE OUR PROCESSING ON COMPRESSION
utt_0086 utt 645.75 655.45 -X TECHNOLOGY. IN DETAIL, WE MOUNT A FILE SYSTEM IN A DIRECTORY, AND THEN SYSTEM CALLS ON THIS
utt_0087 utt 655.45 663.62 -X DIRECTORY ARE HANDLED BY COMPRESSDB. IF THE DATABASE SYSTEM IS SET TO STORE DATA IN THIS
utt_0088 utt 663.62 678.28 -X DIRECTORY, IT CAN AUTOMATICALLY ENJOY THE BENEFITS OF DIRECT PROCESSING ON COMPRESSED DATA, BECAUSE COMPRESSDB CAN HANDLE THE SYSTEM CALLS LIKE READ AND WRITE.
utt_0090 utt 680.96 688.30 -X WE VALIDATE THE EFFICACY OF COMPRESSDB BY SUPPORTING VARIOUS KINDS OF DATABASE SYSTEMS,
utt_0091 utt 688.30 703.14 -X INCLUDING SQLITE, LEVELDB, MONGODB, AND CLICKHOUSE. WE EVALUATE OUR METHOD USING SIX REAL-WORLD DATASETS WITH VARIOUS LENGTHS, STRUCTURES, AND CONTENT IN BOTH SINGLE NODE AND CLUSTER
utt_0093 utt 703.14 703.88 -X ENVIRONMENTS.
utt_0094 utt 706.12 713.74 -X WE EVALUATE THE PERFORMANCE OF COMPRESSDB UPON THE FOUR POPULAR AND DIVERSIFIED DATABASES.
utt_0095 utt 714.37 728.94 -X WE EVALUATE THE PERFORMANCE OF THESE SYSTEMS WITH AND WITHOUT OUR STORAGE ENGINE FROM THE THROUGHPUT AND LATENCY PERSPECTIVES. ON AVERAGE, THE DATABASES USING COMPRESSDB ACHIEVE forty%
utt_0097 utt 731.94 737.38 -X THROUGHPUT IMPROVEMENT AND forty-four% LATENCY REDUCTION OVER THE BASELINE.
utt_0098 utt 737.67 752.36 -X WE SHOW THE THROUGHPUT AND LATENCY FOR DIFFERENT DATASETS IN THIS SLIDE. GENERALLY, THE OPERATIONS OF COMPRESSDB ACHIEVE MUCH HIGHER THROUGHPUT OVER THE ORIGINAL FILE SYSTEM. COMPRESSDB
utt_0100 utt 754.57 761.48 -X ACHIEVES thirty-four point four one√ó THROUGHPUT SPEEDUP OVER THE BASELINE.
utt_0101 utt 761.48 775.66 -X WE MEASURE THE SPACE SAVINGS WITH THE METRIC OF COMPRESSION RATIO, WHICH IS DEFINED AS THE SIZE OF THE ORIGINAL DATA DIVIDED BY THE SIZE OF THE COMPRESSED DATA. COMPRESSDB ACHIEVES
utt_0103 utt 776.65 778.41 -X one point eight one COMPRESSION RATIO.
utt_0104 utt 780.68 795.67 -X WE ALSO CONDUCT DETAILED ANALYSIS. FOR EXAMPLE, IN THE LEFT FIGURE, WE EXPLORE THE BLOCK SIZE INFLUENCE ON COMPRESSION RATIO. WE CAN SEE THAT SMALLER BLOCK SIZE CAN INCREASE THE COMPRESSION
utt_0106 utt 795.67 806.60 -X RATIO. THE RIGHT FIGURE EXHIBITS THE TRADEOFF BETWEEN SPACE COST AND PERFORMANCE EXCHANGE, WHICH SHOWS THAT WE CAN TRADE PERFORMANCE FOR SPACE,
utt_0108 utt 806.60 807.92 -X AND VICE VERSA.
utt_0109 utt 810.09 818.92 -X WE USE FILEBENCH TO EVALUATE THE COMPRESSDB IN SINGLE NODE AND DISTRIBUTED SYSTEMS. FILEBENCH
utt_0110 utt 818.92 827.34 -X ALLOCATES A FILE SET WITH VARIOUS DIRECTORIES AND FILES TO SIMULATE REAL WORKLOAD, AND THEN
utt_0111 utt 827.34 836.24 -X PERFORMS READ AND WRITE OPERATIONS TO MEASURE THE IO BEHAVIORS OF GIVEN FILE SYSTEMS. FILEBENCH
utt_0112 utt 836.39 844.41 -X CAN OUTPUT THE RESULTS OF THROUGHPUT, LATENCY, AND BANDWIDTH UTILIZATION. COMPRESSDB ACHIEVES
utt_0113 utt 844.49 852.30 -X BETTER RESULTS IN ALL ASPECTS, INCLUDING THROUGHPUT, LATENCY, AND BANDWIDTH UTILIZATION.
utt_0114 utt 854.63 869.07 -X WE DEVELOP A NOVEL STORAGE ENGINE, CALLED COMPRESSDB, FOR ENABLING RANDOM UPDATES DIRECTLY ON COMPRESSED DATA. COMPRESSDB CAN PUSH DOWN THE OPERATIONS TO THE STORAGE LAYER.
utt_0116 utt 869.07 877.23 -X SPECIFICALLY, WE INTEGRATE COMPRESSDB TO FILE SYSTEMS, WHICH CAN SUPPORT VARIOUS DATABASE SYSTEMS.
utt_0118 utt 879.37 881.90 -1.8775 THANKS! ANY QUESTIONS?
